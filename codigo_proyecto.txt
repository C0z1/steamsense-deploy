EXTRACCION DE CODIGO DEL PROYECTO
Archivos procesados: 61
Archivos omitidos: 0
Extensiones incluidas: .py, .tsx, .ts, .js, .json, .css
============================================================

============================================================
ARCHIVO: extraer_codigo.py
LINEAS: 90
============================================================

import os

# ============================================================
# CONFIGURACION - Ajusta estas variables a tu proyecto
# ============================================================

RUTA_PROYECTO = "."

EXTENSIONES = [".py", ".tsx", ".ts", ".js", ".json", ".css"]

CARPETAS_IGNORAR = {
    "node_modules", "__pycache__", ".next", ".git",
    "dist", "build", ".venv", "venv", "env", "migrations"
}

ARCHIVOS_IGNORAR = {
    "package-lock.json", "yarn.lock", ".env", ".env.example",
    "diagnose_db.py",
}

ARCHIVO_SALIDA = "codigo_proyecto.txt"
MAX_LINEAS_POR_ARCHIVO = 1000  # Aumentado de 500

# ============================================================

def extraer_codigo():
    resultado = []
    archivos_procesados = 0
    archivos_omitidos = 0

    for raiz, carpetas, archivos in os.walk(RUTA_PROYECTO):
        carpetas[:] = [c for c in carpetas if c not in CARPETAS_IGNORAR and not c.startswith(".")]

        for archivo in sorted(archivos):
            if archivo in ARCHIVOS_IGNORAR:
                continue

            _, extension = os.path.splitext(archivo)
            if extension not in EXTENSIONES:
                continue

            ruta_completa = os.path.join(raiz, archivo)
            ruta_relativa = os.path.relpath(ruta_completa, RUTA_PROYECTO)

            try:
                with open(ruta_completa, "r", encoding="utf-8", errors="ignore") as f:
                    lineas = f.readlines()

                total_lineas = len(lineas)
                truncado = False

                if total_lineas > MAX_LINEAS_POR_ARCHIVO:
                    lineas = lineas[:MAX_LINEAS_POR_ARCHIVO]
                    truncado = True

                contenido = "".join(lineas)

                resultado.append(f"\n{'='*60}")
                resultado.append(f"ARCHIVO: {ruta_relativa}")
                resultado.append(f"LINEAS: {total_lineas}" + (" (TRUNCADO)" if truncado else ""))
                resultado.append(f"{'='*60}\n")
                resultado.append(contenido)

                if truncado:
                    resultado.append(f"\n... [Archivo truncado, {total_lineas - MAX_LINEAS_POR_ARCHIVO} lineas omitidas]")

                archivos_procesados += 1

            except Exception as e:
                archivos_omitidos += 1
                print(f"No se pudo leer: {ruta_relativa} -> {e}")

    encabezado = [
        "EXTRACCION DE CODIGO DEL PROYECTO",
        f"Archivos procesados: {archivos_procesados}",
        f"Archivos omitidos: {archivos_omitidos}",
        f"Extensiones incluidas: {', '.join(EXTENSIONES)}",
        "=" * 60 + "\n"
    ]

    with open(ARCHIVO_SALIDA, "w", encoding="utf-8") as f:
        f.write("\n".join(encabezado))
        f.write("\n".join(resultado))

    print(f"\n Listo! Archivo generado: {ARCHIVO_SALIDA}")
    print(f"   Archivos procesados: {archivos_procesados}")
    print(f"   Tamano: {os.path.getsize(ARCHIVO_SALIDA) / 1024:.1f} KB")

if __name__ == "__main__":
    extraer_codigo()

============================================================
ARCHIVO: backend\config.py
LINEAS: 80
============================================================

"""
config.py
=========
Configuración central del proyecto.
Todas las variables de entorno se leen aquí — en ningún otro lugar.
"""

import os
from functools import lru_cache


class Settings:
    # ── Steam Web API ───────────────────────────────────────────
    steam_api_key: str = os.getenv("STEAM_API_KEY", "")
    jwt_secret: str = os.getenv("JWT_SECRET", "steamsense-dev-secret-change-in-prod")

    # ── IsThereAnyDeal ──────────────────────────────────────────
    itad_api_key: str = os.getenv("ITAD_API_KEY", "")
    itad_base_url: str = os.getenv("ITAD_BASE_URL", "https://api.isthereanydeal.com")
    itad_country: str = os.getenv("ITAD_COUNTRY", "US")
    itad_history_since: str = os.getenv("ITAD_HISTORY_SINCE", "2022-01-01T00:00:00Z")

    # ── DuckDB ──────────────────────────────────────────────────
    duckdb_path: str = os.getenv("DUCKDB_PATH", "./data/steamsense.duckdb")
    duckdb_memory_limit: str = os.getenv("DUCKDB_MEMORY_LIMIT", "512MB")
    duckdb_threads: int = int(os.getenv("DUCKDB_THREADS", "2"))

    # ── API ─────────────────────────────────────────────────────
    api_host: str = os.getenv("API_HOST", "0.0.0.0")
    api_port: int = int(os.getenv("API_PORT", "8000"))
    cors_origins: str = os.getenv("CORS_ORIGINS", "http://localhost:3000")

    # ── Comportamiento ──────────────────────────────────────────
    env: str = os.getenv("ENV", "development")
    top_n_games: int = int(os.getenv("TOP_N_GAMES", "200"))
    request_batch_size: int = int(os.getenv("REQUEST_BATCH_SIZE", "10"))
    request_delay: float = float(os.getenv("REQUEST_DELAY", "0.5"))

    @property
    def cors_origins_list(self) -> list[str]:
        return [o.strip() for o in self.cors_origins.split(",")]

    @property
    def is_production(self) -> bool:
        return self.env == "production"

    def __init__(self):
        # Load .env file if it exists
        env_path = os.path.join(os.path.dirname(__file__), ".env")
        if os.path.exists(env_path):
            with open(env_path) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#") and "=" in line:
                        key, _, val = line.partition("=")
                        os.environ.setdefault(key.strip(), val.strip())
        # Re-read after .env loaded
        self.steam_api_key = os.getenv("STEAM_API_KEY", "")
        self.jwt_secret = os.getenv("JWT_SECRET", "steamsense-dev-secret-change-in-prod")
        self.itad_api_key = os.getenv("ITAD_API_KEY", "")
        self.itad_base_url = os.getenv("ITAD_BASE_URL", "https://api.isthereanydeal.com")
        self.itad_country = os.getenv("ITAD_COUNTRY", "US")
        self.itad_history_since = os.getenv("ITAD_HISTORY_SINCE", "2022-01-01T00:00:00Z")
        self.duckdb_path = os.getenv("DUCKDB_PATH", "./data/steamsense.duckdb")
        self.duckdb_memory_limit = os.getenv("DUCKDB_MEMORY_LIMIT", "512MB")
        self.duckdb_threads = int(os.getenv("DUCKDB_THREADS", "2"))
        self.cors_origins = os.getenv("CORS_ORIGINS", "http://localhost:3000")
        self.env = os.getenv("ENV", "development")
        self.top_n_games = int(os.getenv("TOP_N_GAMES", "200"))
        self.request_batch_size = int(os.getenv("REQUEST_BATCH_SIZE", "10"))
        self.request_delay = float(os.getenv("REQUEST_DELAY", "0.5"))


_settings = None

def get_settings() -> Settings:
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


============================================================
ARCHIVO: backend\main.py
LINEAS: 99
============================================================

"""
main.py — SteamSense API entry point.
"""
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.responses import ORJSONResponse
from fastapi.middleware.cors import CORSMiddleware

from config import get_settings
from src.db.connection import init_db, get_db, close_db
from src.db.models import create_all_tables, create_user_tables
from src.ml.model import get_model

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s [%(name)s] %(message)s",
)
logger = logging.getLogger(__name__)
settings = get_settings()


@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Iniciando SteamSense API...")

    init_db()           # solo configura _db_path, no abre conexión
    con = get_db()      # abre la conexión del main thread
    create_all_tables(con)
    create_user_tables(con)
    logger.info("DuckDB listo")

    get_model()
    logger.info("Modelo ML listo")

    if not settings.itad_api_key:
        logger.warning("ITAD_API_KEY no configurada")
    if not settings.steam_api_key:
        logger.warning("STEAM_API_KEY no configurada — login con Steam deshabilitado")

    logger.info(f"SteamSense API lista — modo: {settings.env}")
    yield

    close_db()
    logger.info("SteamSense API detenida")


app = FastAPI(
    title="SteamSense API",
    description="ML predictor de momentos optimos de compra en Steam",
    version="2.0.0",
    lifespan=lifespan,
    default_response_class=ORJSONResponse,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Import routers here (after app creation) to avoid circular import issues
from src.routes import games, prices, predict, sync, stats, auth, user  # noqa: E402

app.include_router(games.router)
app.include_router(prices.router)
app.include_router(predict.router)
app.include_router(sync.router)
app.include_router(stats.router)
app.include_router(auth.router)
app.include_router(user.router)


@app.get("/", tags=["health"])
def root():
    return {"app": "SteamSense API", "version": "2.0.0", "status": "ok"}


@app.get("/health", tags=["health"])
def health():
    try:
        get_db().execute("SELECT 1").fetchone()
        db_status = "ok"
    except Exception:
        db_status = "error"

    model = get_model()
    model_status = "trained" if model._model is not None else "heuristic"

    return {
        "status": "ok",
        "db": db_status,
        "model": model_status,
        "env": settings.env,
        "steam_auth": "enabled" if settings.steam_api_key else "disabled",
    }

============================================================
ARCHIVO: backend\src\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\api\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\api\client.py
LINEAS: 233
============================================================

"""
src/api/client.py
=================
Cliente HTTP para IsThereAnyDeal API.
Maneja: autenticación, retry con backoff, rate limiting, parsing de respuestas.

Una sola instancia se crea en el lifespan de FastAPI y se reutiliza.
"""

import asyncio
import logging
from typing import Optional

import httpx

from config import get_settings
from src.api.schemas import ITADLookupResponse, ITADGame, PriceRecord, ITADSearchResult

logger = logging.getLogger(__name__)

settings = get_settings()


class ITADClient:
    """
    Cliente async para IsThereAnyDeal API v2.
    Docs: https://itad.docs.apiary.io
    """

    def __init__(self, api_key: str):
        if not api_key:
            raise ValueError("ITAD_API_KEY es requerida")
        self._key = api_key
        self._base = settings.itad_base_url
        self._client: Optional[httpx.AsyncClient] = None

    async def __aenter__(self):
        self._client = httpx.AsyncClient(
            timeout=httpx.Timeout(30.0, connect=10.0),
            limits=httpx.Limits(max_connections=20, max_keepalive_connections=10),
        )
        return self

    async def __aexit__(self, *_):
        if self._client:
            await self._client.aclose()

    def _params(self, extra: dict) -> dict:
        """Agrega la API key a todos los requests."""
        return {"key": self._key, **extra}

    async def _get(self, path: str, params: dict, retries: int = 3) -> Optional[dict]:
        """GET con retry exponencial."""
        url = f"{self._base}{path}"
        for attempt in range(retries):
            try:
                r = await self._client.get(url, params=self._params(params))
                if r.status_code == 200:
                    return r.json()
                if r.status_code == 429:
                    wait = 2 ** attempt
                    logger.warning(f"Rate limit hit, esperando {wait}s...")
                    await asyncio.sleep(wait)
                    continue
                logger.debug(f"HTTP {r.status_code} en {path}")
                return None
            except httpx.TimeoutException:
                logger.warning(f"Timeout en {path} (intento {attempt + 1})")
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Error en {path}: {e}")
                return None
        return None

    # ── Endpoints públicos ────────────────────────────────────────────────────

    async def lookup_game(self, appid: int) -> Optional[tuple[str, str, str]]:
        """
        Convierte un Steam appid en datos de ITAD.
        Retorna (game_id, slug, title) o None si no se encontró.
        """
        data = await self._get("/games/lookup/v1", {"appid": appid})
        if not data:
            return None
        try:
            resp = ITADLookupResponse(**data)
            if resp.found and resp.game:
                return (resp.game.id, resp.game.slug, resp.game.title)
            return None
        except Exception as e:
            logger.debug(f"Error parseando lookup para appid={appid}: {e}")
            return None

    async def get_price_history(
        self,
        game_id: str,
        appid: Optional[int] = None,
        since: Optional[str] = None,
    ) -> list[PriceRecord]:
        """
        Obtiene historial completo de precios de un juego.
        Retorna lista de PriceRecord normalizados.
        """
        params = {
            "id": game_id,
            "country": settings.itad_country,
            "since": since or settings.itad_history_since,
        }
        data = await self._get("/games/history/v2", params)
        if not data:
            logger.warning(f"history/v2 vacío para game_id={game_id}")
            return []

        # ITAD /games/history/v2 puede retornar varias estructuras según versión:
        # A) Lista directa: [{timestamp, deal:{price,regular,cut,shop}}, ...]
        # B) Dict con lista: {"list": [{...}], "urls": {...}}
        # C) Lista de objetos planos: [{timestamp, price:{amount}, cut, shop:{id,name}}]
        if isinstance(data, dict):
            entries = data.get("list") or data.get("prices") or data.get("history") or []
            if not entries:
                # Intentar cualquier lista dentro del dict
                for v in data.values():
                    if isinstance(v, list) and v:
                        entries = v
                        break
        elif isinstance(data, list):
            entries = data
        else:
            entries = []

        if entries:
            logger.info(f"history/v2 → {len(entries)} entradas para {game_id}. "
                        f"Keys del primer entry: {list(entries[0].keys()) if isinstance(entries[0], dict) else type(entries[0])}")
        else:
            logger.warning(f"history/v2 sin entradas para {game_id}. Estructura: {str(data)[:300]}")
            return []

        records = []
        for entry in entries:
            try:
                if not isinstance(entry, dict):
                    continue

                # Estructura A/C: deal anidado
                deal = entry.get("deal") or {}

                # Precio: puede estar en deal.price o directo en entry
                price_obj    = deal.get("price") or entry.get("price") or {}
                regular_obj  = deal.get("regular") or entry.get("regular") or {}
                shop         = deal.get("shop") or entry.get("shop") or {}

                price_amount   = price_obj.get("amount", 0) if isinstance(price_obj, dict) else float(price_obj or 0)
                regular_amount = regular_obj.get("amount", 0) if isinstance(regular_obj, dict) else float(regular_obj or 0)
                cut            = deal.get("cut") if "cut" in deal else entry.get("cut", 0)
                ts             = entry.get("timestamp")

                if not ts:
                    continue

                shop_id   = shop.get("id") if isinstance(shop, dict) else None
                shop_name = shop.get("name", "Steam") if isinstance(shop, dict) else "Steam"

                records.append(PriceRecord(
                    game_id=game_id,
                    appid=appid,
                    timestamp=ts,
                    price_usd=float(price_amount or 0),
                    regular_usd=float(regular_amount or 0),
                    cut_pct=int(cut or 0),
                    shop_id=shop_id,
                    shop_name=shop_name,
                ))
            except Exception as e:
                logger.debug(f"Entry skip: {e} — {str(entry)[:100]}")
                continue

        logger.info(f"Parseados {len(records)}/{len(entries)} registros para {game_id}")
        return records

    async def search_games(self, query: str, limit: int = 20) -> list[ITADSearchResult]:
        """Busca juegos por nombre en ITAD."""
        data = await self._get("/games/search/v1", {"title": query, "results": limit})
        if not data:
            return []
        results = []
        for item in data if isinstance(data, list) else []:
            try:
                results.append(ITADSearchResult(**item))
            except Exception:
                continue
        return results

    async def get_current_prices(self, game_ids: list[str]) -> dict:
        """Obtiene precios actuales de múltiples juegos (batch)."""
        if not game_ids:
            return {}
        params = {
            "id": ",".join(game_ids),
            "country": settings.itad_country,
        }
        data = await self._get("/games/prices/v3", params)
        return data or {}


    async def get_game_info(self, game_id: str) -> Optional[tuple[str, str, str]]:
        """Obtiene título y slug de un juego por su ITAD game_id."""
        data = await self._get("/games/info/v2", {"id": game_id})
        if not data:
            return None
        try:
            item = data[0] if isinstance(data, list) and data else data if isinstance(data, dict) else None
            if not item:
                return None
            title = item.get("title") or item.get("name") or game_id
            slug  = item.get("slug") or game_id
            return (game_id, slug, title)
        except Exception as e:
            logger.debug(f"Error en get_game_info({game_id}): {e}")
            return None


# ── Factory ───────────────────────────────────────────────────────────────────

_client_instance: Optional[ITADClient] = None


def get_client() -> ITADClient:
    """Retorna la instancia singleton del cliente."""
    global _client_instance
    if _client_instance is None:
        _client_instance = ITADClient(settings.itad_api_key)
    return _client_instance



============================================================
ARCHIVO: backend\src\api\schemas.py
LINEAS: 72
============================================================

"""
src/api/schemas.py
==================
Modelos Pydantic que validan y tipan las respuestas de la API de IsThereAnyDeal.
Si la API cambia su estructura, este es el único archivo a editar.
"""

from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field


# ── Lookup (appid → ITAD game ID) ────────────────────────────────────────────

class ITADGame(BaseModel):
    id: str
    slug: str
    title: str


class ITADLookupResponse(BaseModel):
    found: bool
    game: Optional[ITADGame] = None


# ── Price History ─────────────────────────────────────────────────────────────

class ITADPrice(BaseModel):
    amount: float
    amountInt: int
    currency: str = "USD"


class ITADShop(BaseModel):
    id: int
    name: str


class ITADHistoryEntry(BaseModel):
    timestamp: datetime
    deal: Optional[dict] = None  # raw — procesado en client.py

    # Extraídos del deal
    price_usd: float = 0.0
    regular_usd: float = 0.0
    cut_pct: int = 0
    shop_id: Optional[int] = None
    shop_name: str = "Steam"


# ── Search ───────────────────────────────────────────────────────────────────

class ITADSearchResult(BaseModel):
    id: str
    slug: str
    title: str
    type: Optional[str] = None
    mature: bool = False


# ── Internos (lo que guardamos en DuckDB) ────────────────────────────────────

class PriceRecord(BaseModel):
    """Fila normalizada lista para insertar en DuckDB."""
    game_id: str
    appid: Optional[int] = None
    timestamp: datetime
    price_usd: float
    regular_usd: float
    cut_pct: int
    shop_id: Optional[int] = None
    shop_name: str


============================================================
ARCHIVO: backend\src\api\steam_auth.py
LINEAS: 100
============================================================

"""
src/api/steam_auth.py
======================
Steam OpenID authentication + JWT sin dependencias externas.
"""
import base64
import hashlib
import hmac
import json
import logging
import re
import time
from typing import Optional

import httpx
from config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

STEAM_OPENID = "https://steamcommunity.com/openid/login"
STEAM_ID_RE  = re.compile(r"https://steamcommunity\.com/openid/id/(\d+)")


def get_openid_redirect_url(return_url: str) -> str:
    params = {
        "openid.ns":         "http://specs.openid.net/auth/2.0",
        "openid.mode":       "checkid_setup",
        "openid.return_to":  return_url,
        "openid.realm":      return_url.split("/auth")[0],
        "openid.identity":   "http://specs.openid.net/auth/2.0/identifier_select",
        "openid.claimed_id": "http://specs.openid.net/auth/2.0/identifier_select",
    }
    return STEAM_OPENID + "?" + "&".join(f"{k}={v}" for k, v in params.items())


async def verify_openid_response(params: dict) -> Optional[str]:
    check_params = {k: v for k, v in params.items()}
    check_params["openid.mode"] = "check_authentication"
    async with httpx.AsyncClient(timeout=15) as client:
        r = await client.post(STEAM_OPENID, data=check_params)
        if "is_valid:true" not in r.text:
            logger.warning("Steam OpenID verification failed")
            return None
    claimed_id = params.get("openid.claimed_id", "")
    match = STEAM_ID_RE.search(claimed_id)
    return match.group(1) if match else None


def _b64(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).rstrip(b"=").decode()


def _sign(header_b64: str, payload_b64: str, secret: str) -> str:
    msg = f"{header_b64}.{payload_b64}".encode()
    sig = hmac.new(secret.encode(), msg, hashlib.sha256).digest()
    return _b64(sig)


def create_jwt(steam_id: str, display_name: str, avatar_url: str) -> str:
    # Use separators=(',',':') to avoid spaces → deterministic output
    header_b64  = _b64(json.dumps({"alg":"HS256","typ":"JWT"}, separators=(',',':')).encode())
    payload_b64 = _b64(json.dumps({
        "sub":    steam_id,
        "name":   display_name,
        "avatar": avatar_url,
        "iat":    int(time.time()),
        "exp":    int(time.time()) + 86400 * 30,
    }, separators=(',',':')).encode())
    secret = get_settings().jwt_secret
    sig_b64 = _sign(header_b64, payload_b64, secret)
    return f"{header_b64}.{payload_b64}.{sig_b64}"


def decode_jwt(token: str) -> Optional[dict]:
    try:
        parts = token.strip().split(".")
        if len(parts) != 3:
            return None
        header_b64, payload_b64, sig_b64 = parts

        # Verify signature with current secret
        secret = get_settings().jwt_secret
        expected = _sign(header_b64, payload_b64, secret)
        if not hmac.compare_digest(sig_b64, expected):
            logger.debug("JWT firma invalida")
            return None

        # Decode payload
        pad = 4 - len(payload_b64) % 4
        data = json.loads(base64.urlsafe_b64decode(payload_b64 + "=" * (pad % 4)))

        if data.get("exp", 0) < time.time():
            logger.debug("JWT expirado")
            return None

        return data
    except Exception as e:
        logger.debug(f"decode_jwt error: {e}")
        return None


============================================================
ARCHIVO: backend\src\api\steam_client.py
LINEAS: 140
============================================================

"""
src/api/steam_client.py
========================
Cliente para Steam Web API.
"""
import logging
import os
from typing import Optional
import httpx

logger = logging.getLogger(__name__)

STEAM_API   = "https://api.steampowered.com"
STEAM_STORE = "https://store.steampowered.com/api"


def _get_key() -> str:
    """Lee la Steam API key en el momento de usarla — nunca en el import."""
    from config import get_settings
    key = get_settings().steam_api_key or os.getenv("STEAM_API_KEY", "")
    if not key:
        raise ValueError(
            "STEAM_API_KEY no configurada. "
            "Agrégala a tu archivo .env:\n  STEAM_API_KEY=tu_key_aqui"
        )
    return key


class SteamClient:
    def __init__(self):
        pass  # key se lee en cada llamada para que .env reloads funcionen

    async def get_player_summary(self, steam_id: str) -> Optional[dict]:
        try:
            key = _get_key()
        except ValueError as e:
            logger.error(str(e))
            return None
        async with httpx.AsyncClient(timeout=15) as client:
            r = await client.get(
                f"{STEAM_API}/ISteamUser/GetPlayerSummaries/v2/",
                params={"key": key, "steamids": steam_id}
            )
            if r.status_code != 200:
                logger.warning(f"Steam GetPlayerSummaries HTTP {r.status_code}")
                return None
            players = r.json().get("response", {}).get("players", [])
            p = players[0] if players else None
            if p:
                logger.info(f"Perfil Steam obtenido: {p.get('personaname')} ({steam_id})")
            return p

    async def get_owned_games(self, steam_id: str) -> list[dict]:
        try:
            key = _get_key()
        except ValueError as e:
            logger.error(str(e))
            return []
        async with httpx.AsyncClient(timeout=30) as client:
            r = await client.get(
                f"{STEAM_API}/IPlayerService/GetOwnedGames/v1/",
                params={
                    "key": key,
                    "steamid": steam_id,
                    "include_appinfo": 1,
                    "include_played_free_games": 1,
                }
            )
            if r.status_code != 200:
                logger.error(f"GetOwnedGames HTTP {r.status_code}: {r.text[:200]}")
                return []
            data = r.json().get("response", {})
            games = data.get("games", [])
            logger.info(f"Steam librería: {len(games)} juegos para {steam_id}")
            return [{
                "appid":         g.get("appid"),
                "title":         g.get("name", f"App {g.get('appid')}"),
                "playtime_mins": g.get("playtime_forever", 0),
                "last_played":   g.get("rtime_last_played"),
            } for g in games if g.get("appid")]

    async def get_recently_played(self, steam_id: str, count: int = 10) -> list[dict]:
        try:
            key = _get_key()
        except ValueError as e:
            logger.error(str(e))
            return []
        async with httpx.AsyncClient(timeout=15) as client:
            r = await client.get(
                f"{STEAM_API}/IPlayerService/GetRecentlyPlayedGames/v1/",
                params={"key": key, "steamid": steam_id, "count": count}
            )
            if r.status_code != 200:
                return []
            return r.json().get("response", {}).get("games", [])

    async def get_wishlist(self, steam_id: str) -> dict:
        """
        Wishlist pública — no requiere API key.
        Returns: {"items": [...], "status": "ok"|"private"|"error"}
        - status "private" only when HTTP 403 (Steam blocks access for private profiles)
        - status "error" when network/parse issues — do NOT assume private
        - status "ok" when we got valid JSON (items may be empty)
        """
        async with httpx.AsyncClient(timeout=20, follow_redirects=True) as client:
            r = await client.get(
                f"https://store.steampowered.com/wishlist/profiles/{steam_id}/wishlistdata/",
                params={"p": 0},
                headers={"Accept": "application/json"},
            )
            if r.status_code == 403:
                logger.warning(f"Wishlist HTTP 403 para {steam_id} — perfil privado")
                return {"items": [], "status": "private"}
            if r.status_code != 200:
                logger.warning(f"Wishlist HTTP {r.status_code} para {steam_id} — error de red/servidor")
                return {"items": [], "status": "error"}
            try:
                data = r.json()
            except Exception:
                logger.warning(f"Wishlist respuesta no es JSON para {steam_id}")
                return {"items": [], "status": "error"}
            if isinstance(data, list):
                logger.info(f"Wishlist vacía (lista) para {steam_id}")
                return {"items": [], "status": "ok"}
            if not isinstance(data, dict):
                logger.warning(f"Wishlist formato inesperado para {steam_id}: {type(data)}")
                return {"items": [], "status": "error"}
            items = [{"appid": int(k), "title": v.get("name", f"App {k}")}
                     for k, v in data.items() if isinstance(v, dict)]
            logger.info(f"Wishlist: {len(items)} items para {steam_id}")
            return {"items": items, "status": "ok"}


_steam_client: Optional[SteamClient] = None

def get_steam_client() -> SteamClient:
    global _steam_client
    if _steam_client is None:
        _steam_client = SteamClient()
    return _steam_client

============================================================
ARCHIVO: backend\src\db\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\db\connection.py
LINEAS: 77
============================================================

"""
src/db/connection.py
====================
Conexión DuckDB thread-safe.

DuckDB no permite compartir una conexión entre threads (FastAPI usa un thread pool
para endpoints síncronos). Solución: una conexión por thread via threading.local(),
todas apuntando al mismo archivo .duckdb.
"""

import logging
import os
import threading
from typing import Optional

import duckdb

from config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# Una conexión por thread
_local = threading.local()
_db_path: Optional[str] = None


def init_db():
    """
    Configura la ruta de la DB al arrancar la app.
    No abre conexión aquí — get_db() lo hace por thread.
    """
    global _db_path

    db_path = settings.duckdb_path
    os.makedirs(os.path.dirname(os.path.abspath(db_path)), exist_ok=True)
    _db_path = db_path

    logger.info(f"DuckDB configurado en: {db_path}")


def _open_connection() -> duckdb.DuckDBPyConnection:
    """Abre una nueva conexión al archivo DuckDB."""
    con = duckdb.connect(
        _db_path,
        config={
            "memory_limit": settings.duckdb_memory_limit,
            "threads": settings.duckdb_threads,
        }
    )
    return con


def get_db() -> duckdb.DuckDBPyConnection:
    """
    Retorna la conexión DuckDB del thread actual.
    Si no existe todavía para este thread, la crea.
    """
    if _db_path is None:
        raise RuntimeError("DuckDB no inicializado. Llama a init_db() primero.")

    if not hasattr(_local, "connection") or _local.connection is None:
        _local.connection = _open_connection()
        logger.debug(f"Nueva conexión DuckDB para thread {threading.current_thread().name}")

    return _local.connection


def close_db():
    """Cierra la conexión del thread actual (llamado en shutdown)."""
    if hasattr(_local, "connection") and _local.connection is not None:
        try:
            _local.connection.close()
        except Exception:
            pass
        _local.connection = None
    logger.info("DuckDB desconectado")

============================================================
ARCHIVO: backend\src\db\models.py
LINEAS: 106
============================================================

"""
src/db/models.py
================
Definición y creación de tablas en DuckDB.
Ejecutar create_all_tables() una vez al iniciar la app.
"""

import logging

import duckdb

logger = logging.getLogger(__name__)


def create_all_tables(con: duckdb.DuckDBPyConnection):
    """Crea todas las tablas si no existen. Idempotente."""

    # ── games ─────────────────────────────────────────────────────────────────
    # NOTA: appid NO tiene UNIQUE constraint en la tabla para permitir DO UPDATE.
    # La unicidad se garantiza a nivel de lógica en upsert_game.
    con.execute("""
        CREATE TABLE IF NOT EXISTS games (
            id         VARCHAR PRIMARY KEY,
            slug       VARCHAR,
            title      VARCHAR NOT NULL,
            appid      INTEGER,               -- Steam App ID (sin UNIQUE, manejado en upsert)
            created_at TIMESTAMP DEFAULT now()
        )
    """)
    # Índice regular para appid — DuckDB no soporta partial indexes
    con.execute("""
        CREATE INDEX IF NOT EXISTS idx_games_appid ON games (appid)
    """)

    # ── price_history ─────────────────────────────────────────────────────────
    # Usamos SEQUENCE para el id autoincremental — DuckDB lo soporta nativamente.
    con.execute("CREATE SEQUENCE IF NOT EXISTS seq_price_history_id START 1")
    con.execute("""
        CREATE TABLE IF NOT EXISTS price_history (
            id          BIGINT PRIMARY KEY DEFAULT nextval('seq_price_history_id'),
            game_id     VARCHAR NOT NULL,
            appid       INTEGER,
            timestamp   TIMESTAMP NOT NULL,
            price_usd   DECIMAL(10, 2) NOT NULL,
            regular_usd DECIMAL(10, 2),
            cut_pct     INTEGER DEFAULT 0,
            shop_id     INTEGER,
            shop_name   VARCHAR DEFAULT 'Steam',
            UNIQUE (game_id, timestamp, shop_id)
        )
    """)

    # ── predictions_cache ─────────────────────────────────────────────────────
    con.execute("""
        CREATE TABLE IF NOT EXISTS predictions_cache (
            game_id     VARCHAR PRIMARY KEY,
            score       DECIMAL(5, 2),
            signal      VARCHAR,
            reason      VARCHAR,
            features    JSON,
            computed_at TIMESTAMP DEFAULT now()
        )
    """)

    logger.info("Tablas DuckDB verificadas/creadas: games, price_history, predictions_cache")


def create_user_tables(con):
    """Tablas para usuarios autenticados con Steam."""

    con.execute("""
        CREATE TABLE IF NOT EXISTS users (
            steam_id      VARCHAR PRIMARY KEY,
            display_name  VARCHAR,
            avatar_url    VARCHAR,
            profile_url   VARCHAR,
            last_login    TIMESTAMP DEFAULT now(),
            created_at    TIMESTAMP DEFAULT now()
        )
    """)

    # Juegos que el usuario ya posee en Steam
    con.execute("""
        CREATE TABLE IF NOT EXISTS user_games (
            steam_id      VARCHAR NOT NULL,
            appid         INTEGER NOT NULL,
            game_title    VARCHAR,
            playtime_mins INTEGER DEFAULT 0,
            last_played   TIMESTAMP,
            synced_at     TIMESTAMP DEFAULT now(),
            PRIMARY KEY (steam_id, appid)
        )
    """)

    # Wishlist del usuario
    con.execute("""
        CREATE TABLE IF NOT EXISTS user_wishlist (
            steam_id    VARCHAR NOT NULL,
            appid       INTEGER NOT NULL,
            game_title  VARCHAR,
            added_at    TIMESTAMP DEFAULT now(),
            PRIMARY KEY (steam_id, appid)
        )
    """)

    logger.info("Tablas de usuario verificadas/creadas")


============================================================
ARCHIVO: backend\src\db\queries.py
LINEAS: 340
============================================================

"""
src/db/queries.py — única fuente de SQL del proyecto.

NOTAS DuckDB importantes:
  - NOW() no existe → usar datetime de Python como parámetro
  - CURRENT_TIMESTAMP en VALUES junto a '?' lanza BinderException
    → pasar datetime.now() como parámetro explícito
  - INTERVAL literal: solo funciona en WHERE, no en VALUES
  - INSERT OR IGNORE no existe → ON CONFLICT ... DO NOTHING
  - shop_id NULL en UNIQUE → normalizar a -1
"""
import json
import logging
import math
import datetime as dt
from typing import Optional

logger = logging.getLogger(__name__)


def _now() -> dt.datetime:
    """Timestamp UTC actual, naive."""
    return dt.datetime.now(dt.timezone.utc).replace(tzinfo=None)


# ── helpers ───────────────────────────────────────────────────────────────────

def _f(v) -> Optional[float]:
    if v is None:
        return None
    try:
        f = float(v)
        return None if (math.isnan(f) or math.isinf(f)) else round(f, 4)
    except (TypeError, ValueError):
        return None


def _san(d: dict) -> dict:
    out = {}
    for k, v in d.items():
        if isinstance(v, float) and (math.isnan(v) or math.isinf(v)):
            out[k] = None
        else:
            out[k] = v
    return out


# ── games ─────────────────────────────────────────────────────────────────────

def upsert_game(con, game_id: str, slug: str, title: str, appid: Optional[int] = None):
    con.execute("""
        INSERT INTO games (id, slug, title, appid)
        VALUES (?, ?, ?, ?)
        ON CONFLICT (id) DO NOTHING
    """, [game_id, slug, title, appid])
    con.execute("UPDATE games SET slug=?, title=? WHERE id=?", [slug, title, game_id])
    if appid:
        con.execute("UPDATE games SET appid=? WHERE id=? AND appid IS NULL", [appid, game_id])


def get_game(con, game_id: str) -> Optional[dict]:
    row = con.execute("SELECT * FROM games WHERE id=?", [game_id]).fetchdf()
    return _san(row.iloc[0].to_dict()) if not row.empty else None


def get_game_by_appid(con, appid: int) -> Optional[dict]:
    row = con.execute("SELECT * FROM games WHERE appid=?", [appid]).fetchdf()
    return _san(row.iloc[0].to_dict()) if not row.empty else None


def list_games(con, limit: int = 50, offset: int = 0) -> list[dict]:
    rows = con.execute("""
        SELECT g.id, g.title, g.appid, g.slug,
               COUNT(ph.id)                   AS total_records,
               COALESCE(MIN(ph.price_usd), 0) AS min_price,
               COALESCE(MAX(ph.cut_pct), 0)   AS max_discount
        FROM games g
        LEFT JOIN price_history ph ON g.id = ph.game_id
        WHERE g.appid IS NOT NULL
          AND g.title IS NOT NULL
          AND LENGTH(g.title) > 0
          AND g.title != g.id
        GROUP BY g.id, g.title, g.appid, g.slug
        ORDER BY total_records DESC
        LIMIT ? OFFSET ?
    """, [limit, offset]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


# ── price_history ─────────────────────────────────────────────────────────────

def upsert_price_records(con, records: list[dict]) -> int:
    """
    Inserta registros de precio sin duplicados.
    - Nunca pasar 'id' (autoincrement SEQUENCE)
    - shop_id NULL → -1 (DuckDB trata cada NULL como distinto en UNIQUE)
    """
    if not records:
        return 0

    import pandas as pd

    df = pd.DataFrame(records)
    df = df.drop(columns=["id"], errors="ignore")

    if "shop_id" in df.columns:
        df["shop_id"] = df["shop_id"].fillna(-1).astype(int)

    valid_cols = ["game_id", "appid", "timestamp", "price_usd",
                  "regular_usd", "cut_pct", "shop_id", "shop_name"]
    df = df[[c for c in valid_cols if c in df.columns]]
    df = df.dropna(subset=["game_id", "timestamp"])

    if df.empty:
        return 0

    before = con.execute("SELECT COUNT(*) FROM price_history").fetchone()[0]

    try:
        con.register("_price_batch", df)
        cols = ", ".join(df.columns)
        con.execute(f"""
            INSERT INTO price_history ({cols})
            SELECT {cols} FROM _price_batch
            ON CONFLICT (game_id, timestamp, shop_id) DO NOTHING
        """)
    except Exception as e:
        logger.error(f"upsert_price_records batch error: {e}")
        cols = ", ".join(df.columns)
        placeholders = ", ".join(["?"] * len(df.columns))
        for _, row in df.iterrows():
            try:
                con.execute(
                    f"INSERT INTO price_history ({cols}) VALUES ({placeholders})"
                    " ON CONFLICT (game_id, timestamp, shop_id) DO NOTHING",
                    list(row)
                )
            except Exception:
                pass
    finally:
        try:
            con.unregister("_price_batch")
        except Exception:
            pass

    after = con.execute("SELECT COUNT(*) FROM price_history").fetchone()[0]
    inserted = after - before
    logger.debug(f"upsert_price_records: {inserted}/{len(df)} insertados")
    return inserted


def get_price_history(con, game_id: str,
                      since: Optional[dt.datetime] = None,
                      until: Optional[dt.datetime] = None) -> list[dict]:
    filters = ["game_id = ?"]
    params  = [game_id]
    if since:
        filters.append("timestamp >= ?")
        params.append(since)
    if until:
        filters.append("timestamp <= ?")
        params.append(until)
    rows = con.execute(f"""
        SELECT timestamp, price_usd, regular_usd, cut_pct, shop_name
        FROM price_history
        WHERE {" AND ".join(filters)}
        ORDER BY timestamp ASC
    """, params).fetchdf()
    return rows.to_dict(orient="records")


def get_price_stats(con, game_id: str) -> Optional[dict]:
    row = con.execute("""
        SELECT
            COALESCE(MIN(price_usd), 0)                              AS min_price,
            COALESCE(MAX(price_usd), 0)                              AS max_price,
            COALESCE(AVG(price_usd), 0)                              AS avg_price,
            COALESCE(MAX(cut_pct), 0)                                AS max_discount,
            COALESCE(AVG(CASE WHEN cut_pct > 0 THEN cut_pct END), 0) AS avg_discount_when_on_sale,
            COUNT(*)                                                  AS total_records,
            MIN(timestamp)                                            AS first_seen,
            MAX(timestamp)                                            AS last_seen,
            COALESCE(AVG(CASE WHEN MONTH(timestamp) IN (10,11,12) AND cut_pct > 0 THEN cut_pct END), 0) AS avg_cut_q4,
            COALESCE(AVG(CASE WHEN MONTH(timestamp) IN (6,7,8)    AND cut_pct > 0 THEN cut_pct END), 0) AS avg_cut_summer
        FROM price_history
        WHERE game_id = ?
    """, [game_id]).fetchone()

    if not row or int(row[5] or 0) == 0:
        return None

    days_since_min = 365
    try:
        min_ts_row = con.execute("""
            SELECT timestamp FROM price_history
            WHERE game_id = ?
              AND price_usd = (SELECT MIN(price_usd) FROM price_history WHERE game_id = ?)
            ORDER BY timestamp DESC LIMIT 1
        """, [game_id, game_id]).fetchone()
        if min_ts_row and min_ts_row[0]:
            ts = min_ts_row[0]
            if hasattr(ts, "replace"):
                ts = ts.replace(tzinfo=None)
                days_since_min = max(0, (dt.datetime.now() - ts).days)
    except Exception:
        pass

    return {
        "min_price":                 _f(row[0]),
        "max_price":                 _f(row[1]),
        "avg_price":                 _f(row[2]),
        "max_discount":              int(row[3] or 0),
        "avg_discount_when_on_sale": _f(row[4]),
        "total_records":             int(row[5]),
        "first_seen":                str(row[6]) if row[6] else None,
        "last_seen":                 str(row[7]) if row[7] else None,
        "avg_cut_q4":                _f(row[8]),
        "avg_cut_summer":            _f(row[9]),
        "days_since_min_price":      days_since_min,
    }


def get_seasonal_patterns(con, game_id: str) -> list[dict]:
    rows = con.execute("""
        SELECT
            MONTH(timestamp) AS month,
            AVG(cut_pct)     AS avg_discount,
            COUNT(*)         AS sample_size,
            MIN(price_usd)   AS min_price
        FROM price_history
        WHERE game_id = ? AND cut_pct > 0
        GROUP BY MONTH(timestamp)
        ORDER BY month
    """, [game_id]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


# ── predictions_cache ─────────────────────────────────────────────────────────

def get_cached_prediction(con, game_id: str, max_age_hours: int = 6) -> Optional[dict]:
    cutoff = _now() - dt.timedelta(hours=max_age_hours)
    row = con.execute("""
        SELECT score, signal, reason, features, computed_at
        FROM predictions_cache
        WHERE game_id = ?
          AND computed_at > ?
    """, [game_id, cutoff]).fetchdf()
    return _san(row.iloc[0].to_dict()) if not row.empty else None


def upsert_prediction(con, game_id: str, score: float, signal: str,
                      reason: str, features: dict):
    now = _now()
    con.execute("""
        INSERT INTO predictions_cache (game_id, score, signal, reason, features, computed_at)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT (game_id) DO UPDATE SET
            score       = excluded.score,
            signal      = excluded.signal,
            reason      = excluded.reason,
            features    = excluded.features,
            computed_at = excluded.computed_at
    """, [game_id, score, signal, reason, json.dumps(features), now])


# ── Overview ──────────────────────────────────────────────────────────────────

def get_overview_stats(con) -> dict:
    row = con.execute("""
        SELECT
            (SELECT COUNT(*) FROM games)         AS total_games,
            (SELECT COUNT(*) FROM price_history) AS total_records,
            (SELECT COUNT(DISTINCT game_id) FROM predictions_cache WHERE signal = 'BUY')  AS buy_signals,
            (SELECT COUNT(DISTINCT game_id) FROM predictions_cache WHERE signal = 'WAIT') AS wait_signals
    """).fetchone()
    return {
        "total_games":   int(row[0] or 0),
        "total_records": int(row[1] or 0),
        "buy_signals":   int(row[2] or 0),
        "wait_signals":  int(row[3] or 0),
    }


def get_top_deals(con, limit: int = 24) -> list[dict]:
    rows = con.execute("""
        WITH latest AS (
            SELECT game_id, price_usd, regular_usd, cut_pct, timestamp,
                   ROW_NUMBER() OVER (PARTITION BY game_id ORDER BY timestamp DESC) AS rn
            FROM price_history
        ),
        mins AS (
            SELECT game_id, MIN(price_usd) AS min_price
            FROM price_history GROUP BY game_id
        )
        SELECT
            g.id, g.title, g.appid,
            l.price_usd                        AS current_price,
            l.regular_usd                      AS regular_price,
            l.cut_pct                          AS discount_pct,
            CAST(l.timestamp AS VARCHAR)       AS last_seen,
            COALESCE(m.min_price, l.price_usd) AS min_price
        FROM latest l
        JOIN games g ON g.id = l.game_id
        JOIN mins  m ON m.game_id = l.game_id
        WHERE l.rn = 1
          AND l.cut_pct > 0
          AND g.appid IS NOT NULL
          AND g.title IS NOT NULL
          AND LENGTH(g.title) > 0
          AND g.title != g.id
        ORDER BY l.cut_pct DESC, l.price_usd ASC
        LIMIT ?
    """, [limit]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


def get_best_predictions(con, signal: str = "BUY", limit: int = 24) -> list[dict]:
    rows = con.execute("""
        WITH latest AS (
            SELECT game_id, price_usd, cut_pct,
                   ROW_NUMBER() OVER (PARTITION BY game_id ORDER BY timestamp DESC) AS rn
            FROM price_history
        )
        SELECT
            g.id, g.title, g.appid,
            pc.score, pc.signal, pc.reason,
            COALESCE(lp.price_usd, 0) AS current_price,
            COALESCE(lp.cut_pct, 0)   AS discount_pct
        FROM predictions_cache pc
        JOIN games g ON g.id = pc.game_id
        LEFT JOIN (SELECT * FROM latest WHERE rn = 1) lp ON lp.game_id = pc.game_id
        WHERE pc.signal = ?
          AND g.appid IS NOT NULL
          AND g.title IS NOT NULL
          AND LENGTH(g.title) > 0
          AND g.title != g.id
        ORDER BY pc.score DESC
        LIMIT ?
    """, [signal, limit]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]

============================================================
ARCHIVO: backend\src\db\user_queries.py
LINEAS: 205
============================================================

"""
src/db/user_queries.py — queries para usuarios, librería y wishlist.

FIX: DuckDB lanza BinderException cuando se mezclan parámetros '?' con
     CURRENT_TIMESTAMP en la misma cláusula VALUES.
     Solución: pasar datetime.now() como parámetro Python explícito.
"""
import logging
import math
from datetime import datetime, timezone
from typing import Optional

logger = logging.getLogger(__name__)


def _now() -> datetime:
    """Timestamp UTC actual, naive (DuckDB no maneja tzinfo)."""
    return datetime.now(timezone.utc).replace(tzinfo=None)


def _san(d: dict) -> dict:
    return {k: (None if isinstance(v, float) and (math.isnan(v) or math.isinf(v)) else v)
            for k, v in d.items()}


def upsert_user(con, steam_id: str, display_name: str, avatar_url: str, profile_url: str):
    now = _now()
    con.execute("""
        INSERT INTO users (steam_id, display_name, avatar_url, profile_url, last_login)
        VALUES (?, ?, ?, ?, ?)
        ON CONFLICT (steam_id) DO UPDATE SET
            display_name = excluded.display_name,
            avatar_url   = excluded.avatar_url,
            profile_url  = excluded.profile_url,
            last_login   = excluded.last_login
    """, [steam_id, display_name, avatar_url, profile_url, now])


def get_user(con, steam_id: str) -> Optional[dict]:
    row = con.execute("SELECT * FROM users WHERE steam_id = ?", [steam_id]).fetchdf()
    return _san(row.iloc[0].to_dict()) if not row.empty else None


def sync_user_library(con, steam_id: str, games: list[dict]) -> int:
    if not games:
        return 0
    inserted = 0
    now = _now()
    for g in games:
        try:
            last_played = None
            if g.get("last_played") and int(g["last_played"]) > 0:
                last_played = datetime.fromtimestamp(int(g["last_played"]))
            con.execute("""
                INSERT INTO user_games (steam_id, appid, game_title, playtime_mins, last_played, synced_at)
                VALUES (?, ?, ?, ?, ?, ?)
                ON CONFLICT (steam_id, appid) DO UPDATE SET
                    game_title    = excluded.game_title,
                    playtime_mins = excluded.playtime_mins,
                    last_played   = excluded.last_played,
                    synced_at     = excluded.synced_at
            """, [steam_id, g["appid"], g.get("title"), g.get("playtime_mins", 0), last_played, now])
            inserted += 1
        except Exception as e:
            logger.debug(f"sync_user_library error appid={g.get('appid')}: {e}")
    return inserted


def sync_user_wishlist(con, steam_id: str, items: list[dict]) -> int:
    if not items:
        return 0
    inserted = 0
    now = _now()
    for item in items:
        try:
            con.execute("""
                INSERT INTO user_wishlist (steam_id, appid, game_title, added_at)
                VALUES (?, ?, ?, ?)
                ON CONFLICT (steam_id, appid) DO NOTHING
            """, [steam_id, item["appid"], item.get("title"), now])
            inserted += 1
        except Exception as e:
            logger.debug(f"sync_user_wishlist error appid={item.get('appid')}: {e}")
    return inserted


def get_user_library(con, steam_id: str) -> list[dict]:
    rows = con.execute("""
        SELECT
            ug.appid,
            ug.game_title,
            ug.playtime_mins,
            ug.last_played,
            g.id                             AS game_id,
            COALESCE(ps.min_price, 0)        AS min_price,
            COALESCE(ps.avg_price, 0)        AS avg_price,
            COALESCE(ps.max_discount, 0)     AS max_discount,
            COALESCE(ps.total_records, 0)    AS total_records
        FROM user_games ug
        LEFT JOIN games g ON g.appid = ug.appid
        LEFT JOIN (
            SELECT game_id,
                   MIN(price_usd) AS min_price,
                   AVG(price_usd) AS avg_price,
                   MAX(cut_pct)   AS max_discount,
                   COUNT(*)       AS total_records
            FROM price_history
            GROUP BY game_id
        ) ps ON ps.game_id = g.id
        WHERE ug.steam_id = ?
        ORDER BY ug.playtime_mins DESC
    """, [steam_id]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


def get_user_wishlist_with_prices(con, steam_id: str) -> list[dict]:
    rows = con.execute("""
        WITH latest AS (
            SELECT game_id, price_usd, regular_usd, cut_pct,
                   ROW_NUMBER() OVER (PARTITION BY game_id ORDER BY timestamp DESC) AS rn
            FROM price_history
        )
        SELECT
            uw.appid,
            uw.game_title,
            uw.added_at,
            g.id                             AS game_id,
            COALESCE(lp.price_usd, 0)        AS current_price,
            COALESCE(lp.cut_pct, 0)          AS discount_pct,
            COALESCE(ps.min_price, 0)        AS all_time_low,
            COALESCE(ps.avg_price, 0)        AS avg_price,
            pc.score,
            pc.signal
        FROM user_wishlist uw
        LEFT JOIN games g ON g.appid = uw.appid
        LEFT JOIN (SELECT * FROM latest WHERE rn = 1) lp ON lp.game_id = g.id
        LEFT JOIN (
            SELECT game_id,
                   MIN(price_usd) AS min_price,
                   AVG(price_usd) AS avg_price
            FROM price_history GROUP BY game_id
        ) ps ON ps.game_id = g.id
        LEFT JOIN predictions_cache pc ON pc.game_id = g.id
        WHERE uw.steam_id = ?
        ORDER BY COALESCE(pc.score, 0) DESC, COALESCE(lp.cut_pct, 0) DESC
    """, [steam_id]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


def get_user_owned_appids(con, steam_id: str) -> set:
    rows = con.execute(
        "SELECT appid FROM user_games WHERE steam_id = ?", [steam_id]
    ).fetchdf()
    return set(rows["appid"].tolist()) if not rows.empty else set()


def get_recommendations(con, steam_id: str, limit: int = 24) -> list[dict]:
    rows = con.execute("""
        WITH owned AS (
            SELECT appid FROM user_games    WHERE steam_id = ?
            UNION ALL
            SELECT appid FROM user_wishlist WHERE steam_id = ?
        ),
        latest AS (
            SELECT game_id, price_usd, cut_pct,
                   ROW_NUMBER() OVER (PARTITION BY game_id ORDER BY timestamp DESC) AS rn
            FROM price_history
        )
        SELECT
            g.id, g.title, g.appid,
            pc.score, pc.signal, pc.reason,
            COALESCE(lp.price_usd, 0)  AS current_price,
            COALESCE(lp.cut_pct, 0)    AS discount_pct,
            COALESCE(ps.min_price, 0)  AS min_price
        FROM predictions_cache pc
        JOIN games g ON g.id = pc.game_id
        LEFT JOIN (SELECT * FROM latest WHERE rn = 1) lp ON lp.game_id = g.id
        LEFT JOIN (
            SELECT game_id, MIN(price_usd) AS min_price
            FROM price_history GROUP BY game_id
        ) ps ON ps.game_id = g.id
        WHERE pc.signal = 'BUY'
          AND g.appid IS NOT NULL
          AND g.appid NOT IN (SELECT appid FROM owned WHERE appid IS NOT NULL)
        ORDER BY pc.score DESC
        LIMIT ?
    """, [steam_id, steam_id, limit]).fetchdf()
    return [_san(r) for r in rows.to_dict(orient="records")]


def get_library_stats(con, steam_id: str) -> dict:
    row = con.execute("""
        SELECT
            COUNT(*)                      AS total_games,
            SUM(ug.playtime_mins) / 60.0  AS total_hours,
            COUNT(g.id)                   AS tracked_games
        FROM user_games ug
        LEFT JOIN games g ON g.appid = ug.appid
        WHERE ug.steam_id = ?
    """, [steam_id]).fetchone()
    return {
        "total_games":   int(row[0] or 0),
        "total_hours":   round(float(row[1] or 0), 1),
        "tracked_games": int(row[2] or 0),
    }

============================================================
ARCHIVO: backend\src\ml\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\ml\features.py
LINEAS: 132
============================================================

"""
src/ml/features.py
==================
Feature engineering para el modelo ML de predicción de precios.
Toma los datos de precio de DuckDB y construye el vector de features.

Features extraídas:
  - current_discount_pct    → % de descuento actual
  - days_since_min_price    → días transcurridos desde el mínimo histórico
  - price_vs_avg_ratio      → precio actual / precio promedio histórico
  - max_historical_discount → mayor descuento registrado
  - avg_discount_q4         → descuento promedio en Q4 (temporada de rebajas)
  - avg_discount_summer     → descuento promedio en verano (Steam Summer Sale)
  - current_month           → mes actual (1–12) para detectar estacionalidad
  - days_since_last_sale    → días desde la última vez que hubo descuento
  - sale_frequency          → proporción de registros que tuvieron descuento
"""

import logging
from datetime import datetime, timezone
from typing import Optional

import numpy as np

logger = logging.getLogger(__name__)


def build_features(stats: dict, history: list[dict], seasonal: list[dict]) -> Optional[dict]:
    """
    Construye el vector de features a partir de los datos de DuckDB.

    Args:
        stats:    Resultado de queries.get_price_stats()
        history:  Resultado de queries.get_price_history()
        seasonal: Resultado de queries.get_seasonal_patterns()

    Returns:
        Dict con features normalizadas, o None si no hay datos suficientes.
    """
    if not history or len(history) < 3:
        logger.debug("Historial insuficiente para construir features")
        return None

    now = datetime.now(timezone.utc)

    # ── Precio actual (último registro) ──────────────────────────────────────
    last = history[-1]
    current_price = float(last.get("price_usd", 0))
    current_cut = int(last.get("cut_pct", 0))

    # ── Stats básicas ─────────────────────────────────────────────────────────
    min_price = float(stats.get("min_price") or 0)
    max_price = float(stats.get("max_price") or current_price)
    avg_price = float(stats.get("avg_price") or current_price)
    max_discount = float(stats.get("max_discount") or 0)

    # ── Ratio precio actual vs promedio ──────────────────────────────────────
    price_vs_avg = (current_price / avg_price) if avg_price > 0 else 1.0

    # ── Días desde el mínimo histórico ───────────────────────────────────────
    days_since_min = float(stats.get("days_since_min_price") or 365)

    # ── Frecuencia de ventas ──────────────────────────────────────────────────
    total_records = len(history)
    on_sale_records = sum(1 for r in history if int(r.get("cut_pct", 0)) > 0)
    sale_frequency = on_sale_records / total_records if total_records > 0 else 0

    # ── Días desde la última venta ────────────────────────────────────────────
    days_since_last_sale = 9999
    for record in reversed(history):
        if int(record.get("cut_pct", 0)) > 0:
            ts = record.get("timestamp")
            if ts:
                if hasattr(ts, "tzinfo") and ts.tzinfo is None:
                    ts = ts.replace(tzinfo=timezone.utc)
                days_since_last_sale = (now - ts).days
            break

    # ── Patrones estacionales ─────────────────────────────────────────────────
    seasonal_map = {int(s["month"]): float(s["avg_discount"]) for s in seasonal}
    avg_cut_q4 = float(stats.get("avg_cut_q4") or 0)
    avg_cut_summer = float(stats.get("avg_cut_summer") or 0)
    current_month = now.month

    # ── Tendencia de precio (pendiente de regresión lineal simple) ────────────
    prices = [float(r.get("price_usd", 0)) for r in history if float(r.get("price_usd", 0)) > 0]
    price_trend = 0.0
    if len(prices) >= 5:
        x = np.arange(len(prices))
        coeffs = np.polyfit(x, prices, 1)
        price_trend = float(coeffs[0])  # pendiente: negativa = bajando

    features = {
        "current_discount_pct":    current_cut,
        "days_since_min_price":    min(days_since_min, 730),   # cap 2 años
        "price_vs_avg_ratio":      round(price_vs_avg, 4),
        "max_historical_discount": max_discount,
        "avg_discount_q4":         avg_cut_q4,
        "avg_discount_summer":     avg_cut_summer,
        "current_month":           current_month,
        "days_since_last_sale":    min(days_since_last_sale, 730),
        "sale_frequency":          round(sale_frequency, 4),
        "price_trend_slope":       round(price_trend, 6),
        # Meta (no usados por el modelo, útiles para el frontend)
        "_current_price":          current_price,
        "_min_price":              min_price,
        "_max_price":              max_price,
        "_avg_price":              avg_price,
    }

    logger.debug(f"Features construidas: {features}")
    return features


def features_to_vector(features: dict) -> np.ndarray:
    """
    Convierte el dict de features al vector ordenado que espera el modelo.
    El orden debe coincidir exactamente con el que se usó en train.py.
    """
    FEATURE_ORDER = [
        "current_discount_pct",
        "days_since_min_price",
        "price_vs_avg_ratio",
        "max_historical_discount",
        "avg_discount_q4",
        "avg_discount_summer",
        "current_month",
        "days_since_last_sale",
        "sale_frequency",
        "price_trend_slope",
    ]
    return np.array([features.get(k, 0) for k in FEATURE_ORDER], dtype=float)


============================================================
ARCHIVO: backend\src\ml\model.py
LINEAS: 204
============================================================

"""
src/ml/model.py
===============
Carga el modelo ML serializado y expone predict().
Si no hay modelo entrenado, usa una heurística de fallback
para que la app funcione desde el día 1.

El modelo entrenado se guarda en src/ml/artifacts/model.joblib
"""

import logging
import os
from dataclasses import dataclass
from typing import Optional

import numpy as np

logger = logging.getLogger(__name__)

ARTIFACT_PATH = os.path.join(os.path.dirname(__file__), "artifacts", "model.joblib")


@dataclass
class PredictionResult:
    score: float          # 0–100. Mayor = mejor momento para comprar
    signal: str           # "BUY" | "WAIT"
    reason: str           # Explicación legible
    confidence: float     # 0–1. Confianza del modelo
    features_used: dict   # Features que alimentaron la predicción


class SteamPriceModel:
    """
    Wrapper del modelo ML.
    Primero intenta cargar el joblib; si no existe, usa la heurística.
    """

    def __init__(self):
        self._model = None
        self._scaler = None
        self._load()

    def _load(self):
        if not os.path.exists(ARTIFACT_PATH):
            logger.warning(
                f"Modelo no encontrado en {ARTIFACT_PATH}. "
                "Usando heurística de fallback. Ejecuta train.py para entrenar."
            )
            return
        try:
            import joblib
            artifact = joblib.load(ARTIFACT_PATH)
            self._model = artifact.get("model")
            self._scaler = artifact.get("scaler")
            logger.info("Modelo ML cargado correctamente desde artifacts/")
        except Exception as e:
            logger.error(f"Error cargando modelo: {e}. Usando heurística.")

    def predict(self, features: dict) -> PredictionResult:
        """
        Genera una predicción dado el dict de features.
        Intenta usar el modelo; si falla, usa heurística.
        """
        from src.ml.features import features_to_vector

        vector = features_to_vector(features)

        if self._model is not None:
            return self._predict_with_model(vector, features)
        else:
            return self._heuristic(features)

    def _predict_with_model(self, vector: np.ndarray, features: dict) -> PredictionResult:
        try:
            X = vector.reshape(1, -1)
            if self._scaler:
                X = self._scaler.transform(X)

            score_raw = float(self._model.predict(X)[0])
            score = max(0.0, min(100.0, score_raw))
            confidence = 0.85  # TODO: calibration

            signal, reason = self._interpret(score, features)
            return PredictionResult(
                score=round(score, 1),
                signal=signal,
                reason=reason,
                confidence=confidence,
                features_used=features,
            )
        except Exception as e:
            logger.error(f"Error en predicción con modelo: {e}. Fallback a heurística.")
            return self._heuristic(features)

    def _heuristic(self, features: dict) -> PredictionResult:
        """
        Heurística basada en reglas cuando no hay modelo entrenado.
        Sirve como baseline y como fallback de producción.
        """
        score = 50.0  # base neutral

        cut = features.get("current_discount_pct", 0)
        max_cut = features.get("max_historical_discount", 0)
        price_ratio = features.get("price_vs_avg_ratio", 1.0)
        days_since_min = features.get("days_since_min_price", 365)
        days_since_sale = features.get("days_since_last_sale", 9999)
        sale_freq = features.get("sale_frequency", 0)
        month = features.get("current_month", 6)
        trend = features.get("price_trend_slope", 0)

        # Descuento actual
        if cut >= 75:
            score += 35
        elif cut >= 50:
            score += 25
        elif cut >= 25:
            score += 12
        elif cut > 0:
            score += 5

        # Precio actual vs promedio
        if price_ratio < 0.6:
            score += 15
        elif price_ratio < 0.8:
            score += 8
        elif price_ratio > 1.1:
            score -= 8

        # Proximidad al mínimo histórico
        if days_since_min < 30:
            score += 20
        elif days_since_min < 90:
            score += 10

        # Hace cuánto fue la última sale (si es inminente, esperar)
        if days_since_sale < 14:
            score -= 5   # acaba de estar en sale
        elif days_since_sale > 300 and sale_freq > 0.2:
            score += 10  # lleva mucho sin sale, pronto habrá una

        # Temporadas de ventas
        if month in (11, 12):  # Q4 / Black Friday / Winter Sale
            score += 8
        elif month in (6, 7):  # Steam Summer Sale
            score += 6

        # Tendencia bajista
        if trend < -0.01:
            score += 5
        elif trend > 0.01:
            score -= 5

        score = max(0.0, min(100.0, score))
        signal, reason = self._interpret(score, features)

        return PredictionResult(
            score=round(score, 1),
            signal=signal,
            reason=reason,
            confidence=0.6,  # heurística = menor confianza
            features_used=features,
        )

    @staticmethod
    def _interpret(score: float, features: dict) -> tuple[str, str]:
        """Convierte el score numérico a señal + razón legible."""
        cut = features.get("current_discount_pct", 0)
        month = features.get("current_month", 6)

        if score >= 75:
            signal = "BUY"
            if cut >= 50:
                reason = f"Descuento del {cut}% — precio cercano a su mínimo histórico."
            else:
                reason = "Múltiples indicadores sugieren este es un buen momento de compra."
        elif score >= 55:
            signal = "BUY"
            reason = "Las condiciones son favorables. Probablemente no habrá un mejor precio pronto."
        elif score >= 40:
            signal = "WAIT"
            if month in (10, 11):
                reason = "Espera unos días — la temporada de rebajas de fin de año está cerca."
            else:
                reason = "El precio está cerca del promedio. Podrías obtenerlo más barato."
        else:
            signal = "WAIT"
            if cut == 0:
                reason = "El juego no está en rebaja. Históricamente suele tener mejores descuentos."
            else:
                reason = "Este descuento es menor que los descuentos históricos típicos."

        return signal, reason


# ── Singleton ─────────────────────────────────────────────────────────────────

_model_instance: Optional[SteamPriceModel] = None


def get_model() -> SteamPriceModel:
    global _model_instance
    if _model_instance is None:
        _model_instance = SteamPriceModel()
    return _model_instance


============================================================
ARCHIVO: backend\src\ml\train.py
LINEAS: 119
============================================================

"""
src/ml/train.py
===============
Script standalone para entrenar/reentrenar el modelo ML.

Uso:
  python -m src.ml.train --db ./data/steamsense.duckdb

Lee datos de DuckDB, construye features para todos los juegos,
entrena un modelo de regresión y serializa en artifacts/model.joblib.

Requiere scikit-learn y joblib (incluidos en requirements.txt).
"""

import argparse
import logging
import os
import sys

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("train")


def train(db_path: str, output_path: str):
    import duckdb
    import numpy as np
    import joblib
    from sklearn.ensemble import GradientBoostingRegressor
    from sklearn.preprocessing import StandardScaler
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_absolute_error, r2_score

    from src.ml.features import build_features, features_to_vector
    from src.db import queries

    logger.info(f"Conectando a DuckDB: {db_path}")
    con = duckdb.connect(db_path)

    # Obtener todos los game_ids que tienen historial
    games = con.execute("""
        SELECT DISTINCT game_id FROM price_history
        GROUP BY game_id HAVING COUNT(*) >= 10
    """).fetchdf()

    logger.info(f"Juegos con historial suficiente: {len(games)}")

    X_rows = []
    y_rows = []

    for game_id in games["game_id"]:
        try:
            stats = queries.get_price_stats(con, game_id)
            history = queries.get_price_history(con, game_id)
            seasonal = queries.get_seasonal_patterns(con, game_id)

            if not stats or not history:
                continue

            # El "label" es el descuento máximo que tuvo el juego
            # (proxy de qué tan bien le fue comprando en ese momento)
            max_cut = float(stats.get("max_discount") or 0)

            # Simular features en diferentes puntos del tiempo (data augmentation)
            for i in range(len(history) - 1, max(len(history) - 10, 0), -2):
                partial_history = history[:i+1]
                feats = build_features(stats, partial_history, seasonal)
                if feats:
                    X_rows.append(features_to_vector(feats))
                    y_rows.append(max_cut)

        except Exception as e:
            logger.warning(f"Error procesando {game_id}: {e}")
            continue

    if len(X_rows) < 20:
        logger.error(f"Datos insuficientes para entrenar ({len(X_rows)} muestras). Necesitas más datos en DuckDB.")
        sys.exit(1)

    X = np.array(X_rows)
    y = np.array(y_rows)

    logger.info(f"Dataset: {X.shape[0]} muestras, {X.shape[1]} features")

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    logger.info("Entrenando GradientBoostingRegressor...")
    model = GradientBoostingRegressor(
        n_estimators=200,
        max_depth=4,
        learning_rate=0.05,
        random_state=42,
    )
    model.fit(X_train_scaled, y_train)

    preds = model.predict(X_test_scaled)
    mae = mean_absolute_error(y_test, preds)
    r2 = r2_score(y_test, preds)

    logger.info(f"MAE: {mae:.2f}  |  R²: {r2:.4f}")

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    joblib.dump({"model": model, "scaler": scaler}, output_path)
    logger.info(f"Modelo guardado en: {output_path}")

    con.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--db", default="./data/steamsense.duckdb")
    parser.add_argument("--output", default=os.path.join(
        os.path.dirname(__file__), "artifacts", "model.joblib"
    ))
    args = parser.parse_args()
    train(args.db, args.output)


============================================================
ARCHIVO: backend\src\routes\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\routes\auth.py
LINEAS: 76
============================================================

"""
src/routes/auth.py
==================
Endpoints de autenticación Steam OpenID.
"""
import logging
from fastapi import APIRouter, HTTPException, Request, Query
from fastapi.responses import RedirectResponse
from config import get_settings
from src.api.steam_auth import get_openid_redirect_url, verify_openid_response, create_jwt
from src.api.steam_client import get_steam_client
from src.db.connection import get_db
from src.db import user_queries

logger = logging.getLogger(__name__)
settings = get_settings()
router = APIRouter(prefix="/auth", tags=["auth"])

FRONTEND_URL = "http://localhost:3000"


@router.get("/steam")
def login_with_steam():
    """Inicia el flujo OpenID — redirige al usuario a Steam."""
    callback = f"http://localhost:8000/auth/steam/callback"
    redirect_url = get_openid_redirect_url(callback)
    return RedirectResponse(redirect_url)


@router.get("/steam/callback")
async def steam_callback(request: Request):
    """
    Steam redirige aquí tras autenticarse.
    Verificamos la identidad, obtenemos el perfil y emitimos un JWT.
    """
    params = dict(request.query_params)
    steam_id = await verify_openid_response(params)

    if not steam_id:
        raise HTTPException(status_code=401, detail="Steam authentication failed")

    # Obtener perfil de Steam
    steam = get_steam_client()
    profile = await steam.get_player_summary(steam_id)

    display_name = profile.get("personaname", f"User {steam_id}") if profile else f"User {steam_id}"
    avatar_url   = profile.get("avatarfull", "") if profile else ""
    profile_url  = profile.get("profileurl", "") if profile else ""

    # Guardar/actualizar usuario en DB
    con = get_db()
    user_queries.upsert_user(con, steam_id, display_name, avatar_url, profile_url)

    # Emitir JWT
    token = create_jwt(steam_id, display_name, avatar_url)

    # Redirigir al frontend con el token
    return RedirectResponse(f"{FRONTEND_URL}/dashboard?token={token}")


@router.get("/me")
async def get_me(request: Request):
    """Retorna el usuario actual basado en el token JWT."""
    from src.api.steam_auth import decode_jwt
    auth = request.headers.get("Authorization", "")
    if not auth.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="No token")
    token = auth[7:]
    payload = decode_jwt(token)
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    return {
        "steam_id":    payload["sub"],
        "display_name": payload["name"],
        "avatar_url":  payload.get("avatar", ""),
    }


============================================================
ARCHIVO: backend\src\routes\games.py
LINEAS: 129
============================================================

"""
src/routes/games.py
"""
import logging
from fastapi import APIRouter, HTTPException, Query
from src.db.connection import get_db
from src.db import queries
from src.api.client import ITADClient
from config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()
router = APIRouter(prefix="/games", tags=["games"])


@router.get("/search")
async def search_games(q: str, limit: int = Query(20, ge=1, le=50)):
    """Busca juegos por nombre en ITAD. Enriquece con appid desde DB local si existe."""
    if not q or len(q.strip()) < 2:
        return []
    try:
        async with ITADClient(settings.itad_api_key) as client:
            results = await client.search_games(q.strip(), limit=limit)

        # FIX: enriquecer resultados con appid desde nuestra DB local.
        # Así el frontend puede mostrar la imagen de Steam en el dropdown.
        con = get_db()
        enriched = []
        for r in results:
            appid = None
            try:
                game = queries.get_game(con, r.id)
                if game:
                    appid = game.get("appid")
            except Exception:
                pass
            enriched.append({
                "id":    r.id,
                "slug":  r.slug,
                "title": r.title,
                "type":  r.type,
                "appid": appid,
            })
        return enriched

    except Exception as e:
        logger.error(f"Search error: {e}")
        return []


@router.get("")
def list_games(limit: int = Query(50, ge=1, le=200), offset: int = Query(0, ge=0)):
    con = get_db()
    return {"games": queries.list_games(con, limit=limit, offset=offset)}


@router.get("/{game_id}")
def get_game(game_id: str):
    con = get_db()
    game = queries.get_game(con, game_id)
    if not game:
        raise HTTPException(status_code=404, detail="Game not found")
    stats    = queries.get_price_stats(con, game_id)
    seasonal = queries.get_seasonal_patterns(con, game_id)
    return {
        "id":                game["id"],
        "title":             game["title"],
        "appid":             game.get("appid"),
        "slug":              game.get("slug"),
        "stats":             stats,
        "seasonal_patterns": seasonal,
    }


@router.get("/{game_id}/current-prices")
async def get_current_prices(game_id: str):
    """Precios actuales de todas las tiendas vía ITAD."""
    try:
        async with ITADClient(settings.itad_api_key) as client:
            import httpx
            async with httpx.AsyncClient(timeout=15) as http:
                r = await http.post(
                    f"{settings.itad_base_url}/games/prices/v3",
                    params={"country": settings.itad_country},
                    json=[game_id],
                    headers={
                        "Authorization": f"Bearer {settings.itad_api_key}",
                        "Content-Type": "application/json",
                    }
                )
                if r.status_code != 200:
                    logger.warning(f"ITAD prices/v3 HTTP {r.status_code}: {r.text[:200]}")
                    return {"game_id": game_id, "prices": []}
                data = r.json()

            prices = []
            items = data if isinstance(data, list) else data.get("list", [])
            for item in items:
                for deal in item.get("deals", []):
                    shop        = deal.get("shop", {})
                    price_obj   = deal.get("price", {})
                    regular_obj = deal.get("regular", {})
                    prices.append({
                        "shop_name":   shop.get("name", "Unknown"),
                        "shop_id":     shop.get("id"),
                        "price_usd":   price_obj.get("amount", 0),
                        "regular_usd": regular_obj.get("amount", 0),
                        "cut_pct":     deal.get("cut", 0),
                        "url":         deal.get("url", ""),
                        "drm":         deal.get("drm", []),
                    })
            prices.sort(key=lambda x: x["price_usd"])
            return {"game_id": game_id, "prices": prices}

    except Exception as e:
        logger.error(f"current-prices error para {game_id}: {e}")
        return {"game_id": game_id, "prices": []}


@router.get("/top/deals")
def top_deals(limit: int = Query(12, ge=1, le=100)):  # FIX: le=50 → le=100
    con = get_db()
    return {"deals": queries.get_top_deals(con, limit=limit)}


@router.get("/top/buy")
def top_buy_signals(limit: int = Query(12, ge=1, le=100)):  # FIX: le=50 → le=100
    con = get_db()
    return {"signals": queries.get_best_predictions(con, signal="BUY", limit=limit)}

============================================================
ARCHIVO: backend\src\routes\predict.py
LINEAS: 58
============================================================

"""
src/routes/predict.py
=====================
Endpoints de predicción ML.
"""

from fastapi import APIRouter, HTTPException, Query

from src.services import predict_service

router = APIRouter(prefix="/predict", tags=["predict"])


@router.get("/{game_id}")
def predict(
    game_id: str,
    force_refresh: bool = Query(False, description="Ignorar cache y recalcular"),
):
    """
    Predicción ML: ¿Es buen momento para comprar este juego?

    Retorna:
    - score (0–100): mayor = mejor momento
    - signal: "BUY" | "WAIT"
    - reason: explicación legible
    - price_context: precio actual vs histórico
    """
    try:
        return predict_service.get_prediction(game_id, force_refresh=force_refresh)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.post("/batch")
def predict_batch(limit: int = Query(100, ge=1, le=500)):
    """
    Genera predicciones para todos los juegos que tienen historial suficiente.
    Necesario para poblar Hot Deals y BUY Signals.
    """
    from src.db.connection import get_db
    from src.db import queries as q

    con = get_db()
    games = q.list_games(con, limit=limit, offset=0)
    results = {"ok": 0, "skipped": 0, "errors": 0}

    for game in games:
        game_id = game["id"]
        if not game.get("total_records") or game["total_records"] < 3:
            results["skipped"] += 1
            continue
        try:
            predict_service.get_prediction(game_id, force_refresh=False)
            results["ok"] += 1
        except Exception as e:
            results["errors"] += 1

    return {"status": "done", **results}


============================================================
ARCHIVO: backend\src\routes\prices.py
LINEAS: 36
============================================================

"""
src/routes/prices.py
====================
Endpoints de historial y estadísticas de precios.
"""

from datetime import datetime
from typing import Optional

from fastapi import APIRouter, HTTPException, Query

from src.services import price_service

router = APIRouter(prefix="/prices", tags=["prices"])


@router.get("/{game_id}/history")
def price_history(
    game_id: str,
    since: Optional[datetime] = Query(None, description="Fecha inicio (ISO 8601)"),
    until: Optional[datetime] = Query(None, description="Fecha fin (ISO 8601)"),
):
    """Historial completo de precios de un juego."""
    try:
        return price_service.get_game_history(game_id, since=since, until=until)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/{game_id}/stats")
def price_stats(game_id: str):
    """Estadísticas agregadas: mínimo histórico, descuentos por temporada, etc."""
    try:
        return price_service.get_game_stats(game_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


============================================================
ARCHIVO: backend\src\routes\stats.py
LINEAS: 13
============================================================

"""src/routes/stats.py — Dashboard stats"""
from fastapi import APIRouter
from src.db.connection import get_db
from src.db import queries

router = APIRouter(prefix="/stats", tags=["stats"])


@router.get("/overview")
def overview():
    """Stats globales: total juegos, registros, señales."""
    con = get_db()
    return queries.get_overview_stats(con)


============================================================
ARCHIVO: backend\src\routes\sync.py
LINEAS: 78
============================================================

"""
src/routes/sync.py
==================
Endpoints para sincronizar datos de precios desde ITAD y SteamSpy.
"""
import logging
from fastapi import APIRouter, HTTPException, Query, BackgroundTasks
from src.services import sync_service

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/sync", tags=["sync"])


@router.post("/game/{appid}")
async def sync_game_by_appid(appid: int):
    """Sincroniza un juego por Steam appid. Usado por EmptyStateWithSeed."""
    result = await sync_service.sync_by_appid(appid)
    if result["status"] == "not_found":
        raise HTTPException(status_code=404, detail=f"appid {appid} no encontrado en ITAD")
    return result


@router.post("/id/{game_id:path}")
async def sync_game_by_id(game_id: str):
    """Sincroniza un juego por ITAD game_id. Llamado desde GameSearch."""
    result = await sync_service.sync_by_game_id(game_id)
    return result


@router.post("/top")
async def sync_top_games(
    background_tasks: BackgroundTasks,
    top_n: int = Query(100, ge=10, le=500),
):
    """Sincroniza los top N juegos de SteamSpy en segundo plano."""
    background_tasks.add_task(sync_service.sync_top_games, top_n)
    return {"status": "started", "message": f"Sincronizando top {top_n} juegos en segundo plano"}


@router.post("/repair")
async def repair_orphaned_games(background_tasks: BackgroundTasks):
    """
    Busca juegos sin título real o sin appid y los arregla consultando ITAD.
    Corre en background — puede tardar varios minutos dependiendo del número de huérfanos.
    """
    background_tasks.add_task(sync_service.repair_orphaned_games)
    return {
        "status": "started",
        "message": "Repairing orphaned games in background. Check logs for progress.",
    }


@router.post("/predictions")
async def generate_all_predictions(
    background_tasks: BackgroundTasks,
    limit: int = Query(200, ge=1, le=1000),
):
    """Genera predicciones ML para todos los juegos con historial suficiente."""
    async def do_batch():
        from src.db.connection import get_db
        from src.db import queries
        from src.services import predict_service
        con = get_db()
        games = queries.list_games(con, limit=limit, offset=0)
        ok = skipped = errors = 0
        for game in games:
            if not game.get("total_records") or game["total_records"] < 3:
                skipped += 1
                continue
            try:
                predict_service.get_prediction(game["id"], force_refresh=False)
                ok += 1
            except Exception:
                errors += 1
        logger.info(f"Batch predictions done: {ok} ok / {skipped} skipped / {errors} errors")

    background_tasks.add_task(do_batch)
    return {"status": "started", "message": f"Generating predictions for up to {limit} games"}

============================================================
ARCHIVO: backend\src\routes\user.py
LINEAS: 186
============================================================

"""
src/routes/user.py
==================
Endpoints del usuario autenticado: librería, wishlist, recomendaciones.

FIXES sobre el original:
  - Wishlist: detecta perfil privado y retorna sync_meta con feedback
  - Library sync background: genera predicciones post-sync
"""
import logging
from fastapi import APIRouter, HTTPException, Request, BackgroundTasks
from src.api.steam_auth import decode_jwt
from src.api.steam_client import get_steam_client, _get_key
from src.db.connection import get_db
from src.db import user_queries
from src.services import sync_service

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/me", tags=["user"])


def _get_steam_id(request: Request) -> str:
    auth = request.headers.get("Authorization", "")
    if not auth.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Not authenticated")
    payload = decode_jwt(auth[7:])
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    return payload["sub"]


def _check_steam_key():
    try:
        _get_key()
    except ValueError as e:
        raise HTTPException(status_code=503, detail=str(e))


@router.get("/library")
async def get_library(request: Request, sync: bool = False):
    steam_id = _get_steam_id(request)
    con = get_db()

    if sync:
        try:
            steam = get_steam_client()
            games = await steam.get_owned_games(steam_id)
            if games:
                n = user_queries.sync_user_library(con, steam_id, games)
                logger.info(f"Sync directo: {n} juegos para {steam_id}")
            else:
                logger.warning(f"get_owned_games retornó 0 juegos para {steam_id}")
        except Exception as e:
            logger.error(f"Error sync librería: {e}")

    library = user_queries.get_user_library(con, steam_id)
    stats   = user_queries.get_library_stats(con, steam_id)
    return {"steam_id": steam_id, "stats": stats, "games": library}


@router.post("/library/sync")
async def sync_library(request: Request, background_tasks: BackgroundTasks):
    steam_id = _get_steam_id(request)
    _check_steam_key()

    async def do_sync():
        try:
            con = get_db()
            steam = get_steam_client()
            games = await steam.get_owned_games(steam_id)
            if games:
                n = user_queries.sync_user_library(con, steam_id, games)
                logger.info(f"Background sync OK: {n} juegos para {steam_id}")
                # FIX: generar predicciones para juegos del usuario que ya tienen historial
                await _generate_predictions_for_user(con, steam_id)
            else:
                logger.warning(f"Background sync: 0 juegos — perfil privado o key inválida")
        except Exception as e:
            logger.error(f"Background sync falló: {e}")

    background_tasks.add_task(do_sync)
    return {"status": "syncing", "message": "Library sync started"}


async def _generate_predictions_for_user(con, steam_id: str):
    """Genera predicciones para los juegos del usuario que tengan historial en DB."""
    try:
        from src.services import predict_service
        library = user_queries.get_user_library(con, steam_id)
        ok = 0
        for g in library:
            if g.get("game_id") and g.get("total_records", 0) >= 3:
                try:
                    predict_service.get_prediction(g["game_id"], force_refresh=False)
                    ok += 1
                except Exception:
                    pass
        logger.info(f"Predicciones generadas para {ok} juegos de {steam_id}")
    except Exception as e:
        logger.warning(f"Error generando predicciones post-sync: {e}")


@router.get("/wishlist")
async def get_wishlist(request: Request, sync: bool = False):
    steam_id = _get_steam_id(request)
    con = get_db()

    # FIX: metadata de sync para informar al frontend qué pasó
    sync_meta = {
        "synced": False,
        "items_found": 0,
        "items_imported": 0,
        "private_profile": False,
        "error": None,
    }

    if sync:
        try:
            steam = get_steam_client()
            result = await steam.get_wishlist(steam_id)
            items = result.get("items", [])
            status = result.get("status", "error")

            if status == "private":
                # HTTP 403 — Steam blocked access, profile is private
                sync_meta["private_profile"] = True
                sync_meta["error"] = (
                    "Tu wishlist de Steam es privada. "
                    "Ve a Steam → Perfil → Editar → Privacidad y pon "
                    "'Detalles del juego' en Público."
                )
            elif status == "error":
                sync_meta["error"] = (
                    "No se pudo obtener tu wishlist. Revisa tu conexión o intenta más tarde."
                )
            elif len(items) == 0:
                # HTTP 200 + valid empty response — wishlist is truly empty
                sync_meta["synced"] = True
                sync_meta["items_found"] = 0
            else:
                sync_meta["items_found"] = len(items)
                n_imported = user_queries.sync_user_wishlist(con, steam_id, items)
                sync_meta["items_imported"] = n_imported
                sync_meta["synced"] = True
                logger.info(f"Wishlist Steam: {len(items)} items, {n_imported} importados para {steam_id}")

                # Sync precio + predicción para top 15 items
                synced = 0
                for item in items[:15]:
                    if item.get("appid"):
                        try:
                            result = await sync_service.sync_by_appid(item["appid"])
                            if result.get("inserted", 0) > 0:
                                synced += 1
                                from src.services import predict_service
                                if result.get("game_id"):
                                    try:
                                        predict_service.get_prediction(result["game_id"], force_refresh=True)
                                    except Exception:
                                        pass
                        except Exception as e:
                            logger.debug(f"Wishlist item sync error appid={item['appid']}: {e}")
                logger.info(f"Wishlist ITAD sync: {synced} juegos con datos nuevos")

        except Exception as e:
            logger.error(f"Error sync wishlist: {e}")
            sync_meta["error"] = f"Error inesperado: {str(e)[:100]}"

    wishlist = user_queries.get_user_wishlist_with_prices(con, steam_id)
    return {"steam_id": steam_id, "wishlist": wishlist, "sync_meta": sync_meta}


@router.get("/recommendations")
def get_recommendations(request: Request, limit: int = 12):
    steam_id = _get_steam_id(request)
    con = get_db()
    recs = user_queries.get_recommendations(con, steam_id, limit=limit)
    return {"steam_id": steam_id, "recommendations": recs}


@router.get("/owned/{appid}")
def check_owned(request: Request, appid: int):
    steam_id = _get_steam_id(request)
    con = get_db()
    owned = appid in user_queries.get_user_owned_appids(con, steam_id)
    return {"appid": appid, "owned": owned}

============================================================
ARCHIVO: backend\src\services\__init__.py
LINEAS: 0
============================================================



============================================================
ARCHIVO: backend\src\services\predict_service.py
LINEAS: 110
============================================================

"""
src/services/predict_service.py
"""
import logging
import math
from typing import Optional

from src.db import queries
from src.db.connection import get_db
from src.ml.features import build_features
from src.ml.model import get_model, PredictionResult

logger = logging.getLogger(__name__)
CACHE_MAX_AGE_HOURS = 6


def _san(v):
    if isinstance(v, float) and (math.isnan(v) or math.isinf(v)):
        return None
    return v


def get_prediction(game_id: str, force_refresh: bool = False) -> dict:
    con = get_db()

    game = queries.get_game(con, game_id)
    if not game:
        raise ValueError(f"Juego no encontrado: {game_id}")

    # Try cache first
    if not force_refresh:
        cached = queries.get_cached_prediction(con, game_id, CACHE_MAX_AGE_HOURS)
        if cached:
            logger.debug(f"Cache hit para game_id={game_id}")
            # Still need price context — fetch it fresh
            stats = queries.get_price_stats(con, game_id)
            history = queries.get_price_history(con, game_id)
            last = history[-1] if history else {}
            return _format_from_cache(game, cached, stats, last)

    # Full recalculation
    stats    = queries.get_price_stats(con, game_id)
    history  = queries.get_price_history(con, game_id)
    seasonal = queries.get_seasonal_patterns(con, game_id)

    if not history or len(history) < 3:
        raise ValueError(f"Historial insuficiente ({len(history or [])} registros). Mínimo 3.")

    features = build_features(stats, history, seasonal)
    if not features:
        raise ValueError("No se pudieron construir features de predicción")

    model  = get_model()
    result: PredictionResult = model.predict(features)

    queries.upsert_prediction(
        con, game_id=game_id, score=result.score, signal=result.signal,
        reason=result.reason,
        features={k: v for k, v in features.items() if not k.startswith("_")},
    )

    return _format_response(game, result.score, result.signal, result.reason,
                            result.confidence, features, from_cache=False)


def _format_from_cache(game: dict, cached: dict, stats: Optional[dict], last_record: dict) -> dict:
    current_price = _san(float(last_record.get("price_usd", 0) or 0)) or 0
    cut_pct       = int(last_record.get("cut_pct", 0) or 0)
    min_price     = _san(stats.get("min_price", 0) if stats else 0) or 0
    avg_price     = _san(stats.get("avg_price", 0) if stats else 0) or 0
    return {
        "game_id": game["id"],
        "title":   game["title"],
        "appid":   game.get("appid"),
        "prediction": {
            "score":      _san(float(cached.get("score") or 0)) or 0,
            "signal":     cached.get("signal", "WAIT"),
            "reason":     cached.get("reason", ""),
            "confidence": 0.0,
        },
        "price_context": {
            "current_price":        current_price,
            "min_price_ever":       min_price,
            "avg_price":            avg_price,
            "current_discount_pct": cut_pct,
        },
        "from_cache": True,
    }


def _format_response(game: dict, score: float, signal: str, reason: str,
                     confidence: float, features: dict, from_cache: bool) -> dict:
    return {
        "game_id": game["id"],
        "title":   game["title"],
        "appid":   game.get("appid"),
        "prediction": {
            "score":      _san(score) or 0,
            "signal":     signal,
            "reason":     reason,
            "confidence": round(_san(confidence) or 0, 2),
        },
        "price_context": {
            "current_price":        _san(features.get("_current_price", 0)) or 0,
            "min_price_ever":       _san(features.get("_min_price", 0)) or 0,
            "avg_price":            _san(features.get("_avg_price", 0)) or 0,
            "current_discount_pct": _san(features.get("current_discount_pct", 0)) or 0,
        },
        "from_cache": from_cache,
    }


============================================================
ARCHIVO: backend\src\services\price_service.py
LINEAS: 62
============================================================

"""
src/services/price_service.py
"""
import logging
import math
from datetime import datetime
from typing import Optional

from src.db import queries
from src.db.connection import get_db

logger = logging.getLogger(__name__)


def _clean(d: dict) -> dict:
    return {k: (None if isinstance(v, float) and (math.isnan(v) or math.isinf(v)) else v)
            for k, v in d.items()}


def get_game_history(game_id: str, since: Optional[datetime] = None,
                     until: Optional[datetime] = None) -> dict:
    con = get_db()
    game = queries.get_game(con, game_id)
    if not game:
        raise ValueError(f"Juego no encontrado: {game_id}")

    history = queries.get_price_history(con, game_id, since=since, until=until)

    cleaned = []
    for record in history:
        r = _clean(record)
        ts = r.get("timestamp")
        if isinstance(ts, datetime):
            r["timestamp"] = ts.isoformat()
        cleaned.append(r)

    # Return empty history without raising — game page handles it gracefully
    return {
        "game_id": game_id,
        "title":   game.get("title"),
        "appid":   game.get("appid"),
        "count":   len(cleaned),
        "history": cleaned,
    }


def get_game_stats(game_id: str) -> dict:
    con = get_db()
    game = queries.get_game(con, game_id)
    if not game:
        raise ValueError(f"Juego no encontrado: {game_id}")

    stats    = queries.get_price_stats(con, game_id)
    seasonal = queries.get_seasonal_patterns(con, game_id)

    return {
        "game_id":          game_id,
        "title":            game.get("title"),
        "appid":            game.get("appid"),
        "stats":            _clean(stats) if stats else None,
        "seasonal_patterns": [_clean(s) for s in seasonal],
    }


============================================================
ARCHIVO: backend\src\services\sync_service.py
LINEAS: 267
============================================================

"""
src/services/sync_service.py
"""
import asyncio
import logging
from typing import Optional
import httpx
from config import get_settings
from src.api.client import ITADClient
from src.db import queries
from src.db.connection import get_db

logger = logging.getLogger(__name__)
settings = get_settings()


async def get_top_appids(client: httpx.AsyncClient, top_n: int) -> list[int]:
    try:
        r = await client.get("https://steamspy.com/api.php",
                             params={"request": "top100forever"}, timeout=30)
        if r.status_code == 200:
            appids = [int(k) for k in r.json().keys()][:top_n]
            logger.info(f"SteamSpy: {len(appids)} appids obtenidos")
            return appids
    except Exception as e:
        logger.error(f"Error en SteamSpy: {e}")
    return []


async def sync_by_appid(appid: int) -> dict:
    """Sincroniza un juego por Steam appid. Usado por POST /sync/game/{appid}."""
    con = get_db()
    async with ITADClient(settings.itad_api_key) as client:
        lookup = await client.lookup_game(appid)
        if not lookup:
            return {"appid": appid, "status": "not_found", "inserted": 0}
        game_id, slug, title = lookup
        try:
            queries.upsert_game(con, game_id=game_id, slug=slug, title=title, appid=appid)
        except Exception as e:
            logger.debug(f"upsert_game skip appid={appid}: {e}")
        records = await client.get_price_history(game_id, appid=appid)
        if not records:
            return {"game_id": game_id, "title": title, "appid": appid,
                    "status": "no_history", "inserted": 0}
        inserted = queries.upsert_price_records(con, [r.model_dump() for r in records])
        logger.info(f"✓ {title} ({appid}): {inserted} registros")
        return {"game_id": game_id, "title": title, "appid": appid,
                "status": "ok", "inserted": inserted}


async def sync_by_game_id(game_id: str) -> dict:
    """
    Sincroniza un juego por ITAD game_id.
    Usado cuando el usuario hace click en un resultado de búsqueda.

    FIX: después de obtener el historial, hace get_game_info para resolver
    el título real y el appid — antes el juego quedaba con title=game_id y appid=None.
    """
    con = get_db()

    # Insertar placeholder si no existe
    existing = queries.get_game(con, game_id)
    if not existing:
        try:
            queries.upsert_game(con, game_id=game_id, slug=game_id,
                                title=game_id, appid=None)
        except Exception:
            pass

    async with ITADClient(settings.itad_api_key) as client:
        # FIX: resolver título y appid via get_game_info antes de insertar historial
        try:
            info = await client.get_game_info(game_id)
            if info:
                _, slug, title = info
                # Intentar obtener appid via lookup inverso si no lo tenemos
                appid = None
                existing_now = queries.get_game(con, game_id)
                if existing_now:
                    appid = existing_now.get("appid")

                # Si aún no tenemos appid, intentar extraerlo del slug o del historial
                if not appid:
                    try:
                        # ITAD a veces incluye el appid en la respuesta de info
                        appid = info[0] if len(info) > 3 and isinstance(info[3], int) else None
                    except Exception:
                        pass

                queries.upsert_game(con, game_id=game_id, slug=slug,
                                    title=title, appid=appid)
                logger.info(f"Resolved title for {game_id}: '{title}' appid={appid}")
        except Exception as e:
            logger.warning(f"get_game_info failed for {game_id}: {e}")

        # Obtener historial de precios
        records = await client.get_price_history(game_id)
        if not records:
            return {"game_id": game_id, "status": "no_history", "inserted": 0}

        # FIX: intentar extraer appid del primer registro del historial
        try:
            first_appid = records[0].appid if hasattr(records[0], 'appid') else None
            if first_appid:
                queries.upsert_game(con, game_id=game_id, slug=game_id,
                                    title=game_id, appid=first_appid)
        except Exception:
            pass

        inserted = queries.upsert_price_records(con, [r.model_dump() for r in records])
        logger.info(f"✓ game_id={game_id}: {inserted} registros")

        # Devolver título resuelto si lo tenemos
        final = queries.get_game(con, game_id)
        title = final.get("title", game_id) if final else game_id
        appid = final.get("appid") if final else None

        return {"game_id": game_id, "title": title, "appid": appid,
                "status": "ok", "inserted": inserted}


async def repair_orphaned_games(batch_size: int = 10) -> dict:
    """
    Busca juegos en la DB cuyo título es igual a su game_id (huérfanos) o
    que no tienen appid, e intenta resolver su información real vía ITAD.

    Estrategia:
    1. Primero intenta leer el appid desde price_history (ya está guardado ahí).
    2. Si lo encuentra, hace lookup_game(appid) para obtener título y slug.
    3. Si no hay appid en price_history, llama get_game_info(game_id) como fallback.
    """
    con = get_db()

    # Encontrar huérfanos: título == id O appid IS NULL
    rows = con.execute("""
        SELECT id, title, appid FROM games
        WHERE title = id
           OR appid IS NULL
        ORDER BY id
        LIMIT 200
    """).fetchdf()

    if rows.empty:
        return {"status": "ok", "repaired": 0, "failed": 0, "message": "No orphaned games found"}

    orphans = rows.to_dict(orient="records")
    logger.info(f"Found {len(orphans)} orphaned games to repair")

    repaired = 0
    failed   = 0

    async with ITADClient(settings.itad_api_key) as client:
        for i in range(0, len(orphans), batch_size):
            batch = orphans[i:i + batch_size]

            for game in batch:
                game_id = game["id"]
                try:
                    resolved_title = None
                    resolved_slug  = None
                    resolved_appid = game.get("appid")

                    # ── Paso 1: leer appid desde price_history ────────────────
                    if not resolved_appid:
                        ph_row = con.execute("""
                            SELECT appid FROM price_history
                            WHERE game_id = ? AND appid IS NOT NULL
                            LIMIT 1
                        """, [game_id]).fetchone()
                        if ph_row:
                            resolved_appid = int(ph_row[0])
                            logger.info(f"Found appid={resolved_appid} in price_history for {game_id}")

                    # ── Paso 2: lookup por appid → título y slug ──────────────
                    if resolved_appid:
                        lookup = await client.lookup_game(resolved_appid)
                        if lookup:
                            _, resolved_slug, resolved_title = lookup

                    # ── Paso 3: fallback a get_game_info por game_id ──────────
                    if not resolved_title:
                        info = await client.get_game_info(game_id)
                        if info:
                            _, resolved_slug, resolved_title = info

                    # Si aún no tenemos título real, saltar
                    if not resolved_title or resolved_title == game_id:
                        failed += 1
                        continue

                    # ── Aplicar fix en DB ─────────────────────────────────────
                    con.execute(
                        "UPDATE games SET title=?, slug=? WHERE id=?",
                        [resolved_title, resolved_slug or game_id, game_id]
                    )
                    if resolved_appid:
                        con.execute(
                            "UPDATE games SET appid=? WHERE id=? AND appid IS NULL",
                            [resolved_appid, game_id]
                        )

                    repaired += 1
                    logger.info(f"Repaired: {game_id} → '{resolved_title}' appid={resolved_appid}")

                except Exception as e:
                    logger.warning(f"Failed to repair {game_id}: {e}")
                    failed += 1

            await asyncio.sleep(settings.request_delay)

    return {
        "status": "ok",
        "repaired": repaired,
        "failed": failed,
        "total_found": len(orphans),
        "message": f"Repaired {repaired}/{len(orphans)} orphaned games",
    }


async def sync_top_games(top_n: int = 100) -> dict:
    if not settings.itad_api_key:
        raise ValueError("ITAD_API_KEY no configurada")
    summary = {"total_games": 0, "total_inserted": 0, "errors": 0, "synced": []}
    async with httpx.AsyncClient(timeout=30) as http_client:
        appids = await get_top_appids(http_client, top_n)
    if not appids:
        return summary
    logger.info(f"Iniciando sync de {len(appids)} juegos...")
    con = get_db()
    async with ITADClient(settings.itad_api_key) as itad:
        batch_size = settings.request_batch_size
        for i in range(0, len(appids), batch_size):
            batch = appids[i:i + batch_size]
            lookup_results = await asyncio.gather(
                *[itad.lookup_game(appid) for appid in batch],
                return_exceptions=True
            )
            for appid, lookup in zip(batch, lookup_results):
                if isinstance(lookup, Exception) or not lookup:
                    summary["errors"] += 1
                    continue
                game_id, slug, title = lookup
                try:
                    try:
                        queries.upsert_game(con, game_id=game_id, slug=slug,
                                            title=title, appid=appid)
                    except Exception as e:
                        logger.debug(f"upsert_game skip {appid}: {e}")
                    records = await itad.get_price_history(game_id, appid=appid)
                    if records:
                        inserted = queries.upsert_price_records(
                            con, [r.model_dump() for r in records])
                        summary["total_inserted"] += inserted
                        summary["total_games"] += 1
                        summary["synced"].append(appid)
                        logger.info(f"  ✓ {title} ({appid}): {inserted} registros")
                    else:
                        summary["errors"] += 1
                except Exception as e:
                    logger.warning(f"Error appid={appid}: {e}")
                    summary["errors"] += 1
            await asyncio.sleep(settings.request_delay)
            logger.info(f"Progreso: {min(i+batch_size,len(appids))}/{len(appids)} | "
                        f"Insertados: {summary['total_inserted']}")
    logger.info(f"Sync completado: {summary}")
    return summary

============================================================
ARCHIVO: frontend\next-env.d.ts
LINEAS: 5
============================================================

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


============================================================
ARCHIVO: frontend\next.config.js
LINEAS: 9
============================================================

/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  images: {
    domains: ['cdn.cloudflare.steamstatic.com', 'shared.akamai.steamstatic.com'],
  },
}

module.exports = nextConfig


============================================================
ARCHIVO: frontend\package.json
LINEAS: 30
============================================================

{
  "name": "steamsense-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev --port 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.2.5",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "recharts": "^2.12.7",
    "lucide-react": "^0.441.0",
    "clsx": "^2.1.1"
  },
  "devDependencies": {
    "@types/node": "^22.5.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "typescript": "^5.5.4",
    "tailwindcss": "^3.4.1",
    "postcss": "^8.4.40",
    "autoprefixer": "^10.4.20",
    "eslint": "^8.57.0",
    "eslint-config-next": "14.2.5"
  }
}


============================================================
ARCHIVO: frontend\postcss.config.js
LINEAS: 6
============================================================

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


============================================================
ARCHIVO: frontend\tailwind.config.js
LINEAS: 52
============================================================

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,ts,jsx,tsx,mdx}'],
  theme: {
    extend: {
      fontFamily: {
        display: ['var(--font-display)', 'serif'],
        body: ['var(--font-body)', 'sans-serif'],
        mono: ['var(--font-mono)', 'monospace'],
      },
      colors: {
        steam: {
          bg:      '#0a0f1a',
          surface: '#111827',
          card:    '#161e2e',
          border:  '#1f2d45',
          muted:   '#1e2d42',
          cyan:    '#00d4ff',
          green:   '#00ff87',
          amber:   '#ffb800',
          red:     '#ff4757',
          text:    '#c9d6e8',
          subtle:  '#5c7a9e',
        }
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'fade-in': 'fadeIn 0.5s ease forwards',
        'slide-up': 'slideUp 0.4s ease forwards',
        'glow': 'glow 2s ease-in-out infinite alternate',
      },
      keyframes: {
        fadeIn: {
          from: { opacity: '0' },
          to:   { opacity: '1' },
        },
        slideUp: {
          from: { opacity: '0', transform: 'translateY(16px)' },
          to:   { opacity: '1', transform: 'translateY(0)' },
        },
        glow: {
          from: { boxShadow: '0 0 10px rgba(0,212,255,0.2)' },
          to:   { boxShadow: '0 0 25px rgba(0,212,255,0.5)' },
        }
      },
      backgroundImage: {
        'grid-pattern': "url(\"data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%231f2d45' fill-opacity='0.4'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E\")",
      }
    },
  },
  plugins: [],
}


============================================================
ARCHIVO: frontend\tsconfig.json
LINEAS: 21
============================================================

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": { "@/*": ["./src/*"] }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


============================================================
ARCHIVO: frontend\src\app\globals.css
LINEAS: 201
============================================================

@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=DM+Mono:wght@400;500&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;1,9..40,300&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* ── Fuentes ─────────────────────────────────────────────────────────────── */
:root {
  --font-display: 'Syne', sans-serif;
  --font-body:    'DM Sans', sans-serif;
  --font-mono:    'DM Mono', monospace;

  /* ── Tema oscuro (default) ─────────────────────────────────────────────── */
  --color-bg:      #0a0f1a;
  --color-surface: #111827;
  --color-card:    #161e2e;
  --color-border:  #1f2d45;
  --color-muted:   #1e2d42;
  --color-text:    #c9d6e8;
  --color-subtle:  #5c7a9e;

  /* Accent colors — iguales en ambos temas */
  --color-cyan:    #00d4ff;
  --color-green:   #00ff87;
  --color-amber:   #ffb800;
  --color-red:     #ff4757;

  /* Glass (dark) */
  --glass-bg:          rgba(22, 30, 46, 0.8);
  --glass-border:      rgba(31, 45, 69, 0.8);
  --glass-hover-bg:    rgba(22, 30, 46, 0.95);
  --glass-hover-border:rgba(0, 212, 255, 0.25);

  /* Scrollbar */
  --scrollbar-track:   #0a0f1a;
  --scrollbar-thumb:   #1f2d45;
  --scrollbar-hover:   #2d4a6b;

  /* Recharts */
  --recharts-tooltip-bg:     #161e2e;
  --recharts-tooltip-border: #1f2d45;
  --recharts-grid-line:      #1f2d45;
}

/* ── Tema claro ──────────────────────────────────────────────────────────── */
html.light {
  --color-bg:      #f0f4f8;
  --color-surface: #e2e8f0;
  --color-card:    #ffffff;
  --color-border:  #cbd5e1;
  --color-muted:   #e8edf4;
  --color-text:    #1e293b;
  --color-subtle:  #64748b;

  --glass-bg:           rgba(255, 255, 255, 0.85);
  --glass-border:       rgba(203, 213, 225, 0.9);
  --glass-hover-bg:     rgba(255, 255, 255, 0.98);
  --glass-hover-border: rgba(0, 180, 216, 0.4);

  --scrollbar-track:   #f0f4f8;
  --scrollbar-thumb:   #cbd5e1;
  --scrollbar-hover:   #94a3b8;

  --recharts-tooltip-bg:     #ffffff;
  --recharts-tooltip-border: #cbd5e1;
  --recharts-grid-line:      #e2e8f0;
}

/* ── Reset ───────────────────────────────────────────────────────────────── */
* { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; }

body {
  background-color: var(--color-bg);
  color: var(--color-text);
  font-family: var(--font-body);
  -webkit-font-smoothing: antialiased;
  overflow-x: hidden;
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* ── Scrollbar ───────────────────────────────────────────────────────────── */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--scrollbar-track); }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-hover); }

::selection { background: rgba(0, 212, 255, 0.25); color: #fff; }

/* ── Utilities ───────────────────────────────────────────────────────────── */
@layer utilities {
  .text-gradient-cyan {
    background: linear-gradient(135deg, #00d4ff, #00ff87);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .text-gradient-gold {
    background: linear-gradient(135deg, #ffb800, #ff6b35);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Glass — usa las CSS vars para que cambie con el tema */
  .glass {
    background: var(--glass-bg);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--glass-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }
  .glass-hover {
    transition: border-color 0.2s, background 0.2s;
  }
  .glass-hover:hover {
    background: var(--glass-hover-bg);
    border-color: var(--glass-hover-border);
  }

  .glow-cyan  { box-shadow: 0 0 20px rgba(0, 212, 255, 0.15), 0 0 60px rgba(0, 212, 255, 0.05); }
  .glow-green { box-shadow: 0 0 20px rgba(0, 255, 135, 0.15), 0 0 60px rgba(0, 255, 135, 0.05); }
  .glow-amber { box-shadow: 0 0 20px rgba(255, 184, 0, 0.15),  0 0 60px rgba(255, 184, 0, 0.05); }

  .animate-fade-in        { animation: fadeIn  0.4s ease         forwards; }
  .animate-slide-up       { animation: slideUp 0.4s ease         forwards; }
  .animate-slide-up-delay-1 { animation: slideUp 0.4s ease 0.05s forwards; opacity: 0; }
  .animate-slide-up-delay-2 { animation: slideUp 0.4s ease 0.10s forwards; opacity: 0; }
  .animate-slide-up-delay-3 { animation: slideUp 0.4s ease 0.15s forwards; opacity: 0; }

  .scanline {
    background: repeating-linear-gradient(
      0deg, transparent, transparent 2px,
      rgba(0, 0, 0, 0.03) 2px, rgba(0, 0, 0, 0.03) 4px
    );
  }

  .bg-grid-pattern {
    background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none'%3E%3Cg fill='%231f2d45' fill-opacity='0.3'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  }

  /* Versión light del grid */
  html.light .bg-grid-pattern {
    background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none'%3E%3Cg fill='%23cbd5e1' fill-opacity='0.4'%3E%3Cpath d='M0 40L40 0H20L0 20M40 40V20L20 40'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  }
}

/* ── Keyframes ───────────────────────────────────────────────────────────── */
@keyframes fadeIn  { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideUp {
  from { opacity: 0; transform: translateY(16px); }
  to   { opacity: 1; transform: translateY(0); }
}
@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 135, 0.2); }
  50%       { box-shadow: 0 0 25px rgba(0, 255, 135, 0.5), 0 0 50px rgba(0, 255, 135, 0.2); }
}
@keyframes shimmer {
  from { transform: translateX(-100%); }
  to   { transform: translateX(100%); }
}

.animate-pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
.shimmer { position: relative; overflow: hidden; }
.shimmer::after {
  content: '';
  position: absolute; inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.04), transparent);
  animation: shimmer 2s infinite;
}

/* ── Recharts ────────────────────────────────────────────────────────────── */
.recharts-tooltip-wrapper .recharts-default-tooltip {
  background: var(--recharts-tooltip-bg)     !important;
  border:     1px solid var(--recharts-tooltip-border) !important;
  border-radius: 8px !important;
  color: var(--color-text) !important;
}
.recharts-cartesian-grid-horizontal line,
.recharts-cartesian-grid-vertical   line { stroke: var(--recharts-grid-line); }

/* ── Steam color overrides via CSS vars ──────────────────────────────────── */
/*
  Tailwind genera clases como bg-steam-bg usando los valores del config.
  Para el tema light, sobreescribimos directamente el background del body
  y confiamos en las clases .glass y las vars para el resto.
  Los componentes que usen bg-steam-bg necesitan esta regla para actualizarse:
*/
html.light body { background-color: var(--color-bg); }

/* Cards y superficies: sobreescribir bg-steam-card y bg-steam-muted en light */
html.light .bg-steam-bg      { background-color: var(--color-bg) !important; }
html.light .bg-steam-card    { background-color: var(--color-card) !important; }
html.light .bg-steam-muted   { background-color: var(--color-muted) !important; }
html.light .bg-steam-surface { background-color: var(--color-surface) !important; }
html.light .border-steam-border { border-color: var(--color-border) !important; }
html.light .text-steam-text  { color: var(--color-text) !important; }
html.light .text-steam-subtle { color: var(--color-subtle) !important; }

/* Tooltip light */
html.light .recharts-text { fill: var(--color-subtle) !important; }

============================================================
ARCHIVO: frontend\src\app\layout.tsx
LINEAS: 18
============================================================

import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'SteamSense — Buy or Wait?',
  description: 'ML-powered Steam game price prediction. Know exactly when to buy.',
  icons: { icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">🎮</text></svg>' },
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-steam-bg">
        {children}
      </body>
    </html>
  )
}


============================================================
ARCHIVO: frontend\src\app\not-found.tsx
LINEAS: 25
============================================================

import Link from 'next/link'
import { ArrowLeft, Gamepad2 } from 'lucide-react'

export default function NotFound() {
  return (
    <div className="min-h-screen bg-steam-bg flex items-center justify-center px-6">
      <div className="text-center space-y-6">
        <div className="w-20 h-20 mx-auto rounded-2xl bg-steam-card border border-steam-border flex items-center justify-center">
          <Gamepad2 size={36} className="text-steam-subtle" />
        </div>
        <div>
          <h1 className="font-display font-bold text-4xl text-steam-text">404</h1>
          <p className="text-steam-subtle mt-2">Game not found or not synced yet.</p>
        </div>
        <Link
          href="/"
          className="inline-flex items-center gap-2 px-5 py-2.5 bg-steam-cyan/10 border border-steam-cyan/20 text-steam-cyan rounded-xl text-sm font-mono hover:bg-steam-cyan/20 transition-colors"
        >
          <ArrowLeft size={14} />
          Back to search
        </Link>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\app\page.tsx
LINEAS: 179
============================================================

import { Suspense } from 'react'
import { TrendingUp, Database, Zap, Clock, ArrowRight } from 'lucide-react'
import Link from 'next/link'
import Navbar from '@/components/Navbar'
import GameSearch from '@/components/GameSearch'
import GameCard from '@/components/GameCard'
import EmptyStateWithSeed from '@/components/EmptyStateWithSeed'
import { getTopDeals, getTopBuySignals, getOverviewStats } from '@/lib/api'
import type { TopDeal, BuySignal } from '@/lib/types'

function CardSkeleton() {
  return (
    <div className="glass rounded-2xl overflow-hidden animate-pulse">
      <div className="h-32 bg-steam-muted" />
      <div className="p-4 space-y-2">
        <div className="h-4 bg-steam-muted rounded w-3/4" />
        <div className="h-3 bg-steam-muted rounded w-1/2" />
        <div className="h-2 bg-steam-muted rounded" />
      </div>
    </div>
  )
}

function GridSkeleton() {
  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
      {Array.from({ length: 8 }).map((_, i) => <CardSkeleton key={i} />)}
    </div>
  )
}

async function OverviewBar() {
  let stats = { total_games: 0, total_records: 0, buy_signals: 0, wait_signals: 0 }
  try { stats = await getOverviewStats() } catch {}

  const fmt = (n: number) => n > 0 ? n.toLocaleString() : '—'

  return (
    <div className="flex flex-wrap items-center justify-center gap-8 sm:gap-14 py-6">
      {[
        { label: 'Games tracked',  value: fmt(stats.total_games),   icon: Database, color: '' },
        { label: 'Price records',  value: fmt(stats.total_records),  icon: TrendingUp, color: '' },
        { label: 'BUY signals',   value: fmt(stats.buy_signals),    icon: Zap,  color: 'text-steam-green' },
        { label: 'WAIT signals',  value: fmt(stats.wait_signals),   icon: Clock, color: '' },
      ].map(({ label, value, icon: Icon, color }) => (
        <div key={label} className="text-center">
          <div className="flex items-center justify-center gap-1.5 text-steam-subtle text-xs font-mono mb-1">
            <Icon size={11} className={color} />
            {label}
          </div>
          <div className={`font-display font-bold text-xl ${color || 'text-steam-text'}`}>
            {value}
          </div>
        </div>
      ))}
    </div>
  )
}

async function TopDealsSection() {
  let deals: TopDeal[] = []
  try { deals = await getTopDeals(8) } catch {}

  if (!deals.length) return <EmptyStateWithSeed />

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
      {deals.map((d, i) => (
        <GameCard
          key={d.id} id={d.id} title={d.title} appid={d.appid}
          currentPrice={d.current_price} regularPrice={d.regular_price}
          discountPct={d.discount_pct} minPrice={d.min_price}
          lastSeen={d.last_seen} index={i}
        />
      ))}
    </div>
  )
}

async function BuySignalsSection() {
  let signals: BuySignal[] = []
  try { signals = await getTopBuySignals(8) } catch {}

  if (!signals.length) return (
    <div className="text-center py-10 space-y-3">
      <p className="text-steam-subtle text-sm">No BUY signals yet.</p>
      <a href="/explore?tab=buy"
        className="inline-flex items-center gap-2 px-4 py-2 bg-steam-green/10 border border-steam-green/30 rounded-xl text-steam-green text-xs font-mono hover:bg-steam-green/20 transition-all">
        Generate Predictions →
      </a>
    </div>
  )

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
      {signals.map((s, i) => (
        <GameCard
          key={s.id} id={s.id} title={s.title} appid={s.appid}
          currentPrice={s.current_price} discountPct={s.discount_pct}
          score={s.score} signal={s.signal} index={i}
        />
      ))}
    </div>
  )
}

export default function HomePage() {
  return (
    <div className="min-h-screen bg-steam-bg">
      <Navbar />

      {/* Hero */}
      <div className="relative pt-28 pb-12 px-6 overflow-hidden">
        <div className="absolute inset-0 bg-grid-pattern opacity-25 pointer-events-none" />
        <div className="absolute top-0 left-1/2 -translate-x-1/2 w-[700px] h-[350px] rounded-full bg-steam-cyan/4 blur-[100px] pointer-events-none" />

        <div className="relative max-w-3xl mx-auto text-center space-y-7">
          <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-steam-cyan/10 border border-steam-cyan/20 rounded-full text-steam-cyan text-xs font-mono">
            <Zap size={11} /> ML-powered · updated live
          </div>
          <div className="space-y-3">
            <h1 className="font-display font-bold text-5xl sm:text-6xl leading-none tracking-tight">
              <span className="text-steam-text">Buy or</span><br />
              <span className="text-gradient-cyan">Wait?</span>
            </h1>
            <p className="text-steam-subtle text-lg max-w-lg mx-auto leading-relaxed">
              Machine learning analyzes years of Steam price history to tell you exactly when to buy.
            </p>
          </div>
          <GameSearch />
        </div>
      </div>

      {/* Stats bar */}
      <div className="max-w-4xl mx-auto px-6">
        <div className="glass rounded-2xl">
          <Suspense fallback={<div className="h-24 animate-pulse rounded-2xl bg-steam-muted" />}>
            <OverviewBar />
          </Suspense>
        </div>
      </div>

      {/* Content */}
      <div className="max-w-6xl mx-auto px-6 py-12 space-y-14">
        <section>
          <div className="flex items-center justify-between mb-5">
            <div>
              <h2 className="font-display font-bold text-xl text-steam-text">🔥 Hot Deals</h2>
              <p className="text-steam-subtle text-sm mt-0.5">Games currently on sale, sorted by biggest discount</p>
            </div>
            <Link href="/explore?tab=deals" className="flex items-center gap-1 text-steam-subtle text-xs font-mono hover:text-steam-cyan transition-colors">
              See all <ArrowRight size={12} />
            </Link>
          </div>
          <Suspense fallback={<GridSkeleton />}>
            <TopDealsSection />
          </Suspense>
        </section>

        <section>
          <div className="flex items-center justify-between mb-5">
            <div>
              <h2 className="font-display font-bold text-xl text-steam-text">
                <span className="text-steam-green">⚡</span> ML Buy Signals
              </h2>
              <p className="text-steam-subtle text-sm mt-0.5">Games our model says are worth buying right now</p>
            </div>
            <Link href="/explore?tab=buy" className="flex items-center gap-1 text-steam-subtle text-xs font-mono hover:text-steam-cyan transition-colors">
              See all <ArrowRight size={12} />
            </Link>
          </div>
          <Suspense fallback={<GridSkeleton />}>
            <BuySignalsSection />
          </Suspense>
        </section>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\app\dashboard\page.tsx
LINEAS: 602
============================================================

'use client'

import { useEffect, useState, useCallback } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import Image from 'next/image'
import Link from 'next/link'
import {
  Library, Heart, Sparkles, RefreshCw, Clock, TrendingDown,
  Zap, ChevronRight, Star, Database, AlertTriangle,
  Lock, CheckCircle, ExternalLink
} from 'lucide-react'
import Navbar from '@/components/Navbar'
import GameCard from '@/components/GameCard'
import ProfileInsights from '@/components/ProfileInsights'
import PriceAlertButton from '../../components/PriceAlertButton'
import { getToken, getUserFromStorage, type SteamUser } from '@/lib/auth'
import { getLibrary, getWishlist, getRecommendations, syncLibrary } from '@/lib/api'
import { formatPrice, formatDate, timeAgo, steamImageUrl } from '@/lib/utils'

const BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'

type Tab = 'library' | 'wishlist' | 'recs'

// ── Setup Guide ───────────────────────────────────────────────────────────────

function SetupGuide() {
  const [step1Loading, setStep1Loading] = useState(false)
  const [step2Loading, setStep2Loading] = useState(false)
  const [step1Done, setStep1Done]       = useState(false)
  const [step2Done, setStep2Done]       = useState(false)

  const handleSyncTop = async () => {
    setStep1Loading(true)
    try {
      await fetch(`${BASE}/sync/top?top_n=100`, { method: 'POST' })
      setStep1Done(true)
    } catch { } finally { setStep1Loading(false) }
  }

  const handleGenPredictions = async () => {
    setStep2Loading(true)
    try {
      await fetch(`${BASE}/sync/predictions?limit=200`, { method: 'POST' })
      setStep2Done(true)
    } catch { } finally { setStep2Loading(false) }
  }

  return (
    <div className="glass rounded-2xl p-6 border border-steam-amber/20 bg-steam-amber/5 space-y-4">
      <div className="flex items-center gap-3">
        <div className="w-8 h-8 rounded-lg bg-steam-amber/20 flex items-center justify-center flex-shrink-0">
          <Zap size={15} className="text-steam-amber" />
        </div>
        <div>
          <p className="text-steam-text text-sm font-semibold">First-time setup — populate the database</p>
          <p className="text-steam-subtle text-xs mt-0.5">Run these steps once to get BUY signals and recommendations working.</p>
        </div>
      </div>

      <div className="space-y-3">
        {/* Step 1 */}
        <div className="flex items-start gap-4 p-4 glass rounded-xl">
          <div className={`w-7 h-7 rounded-full flex items-center justify-center flex-shrink-0 text-xs font-bold mt-0.5 ${step1Done ? 'bg-steam-green/20 text-steam-green' : 'bg-steam-muted text-steam-subtle'}`}>
            {step1Done ? <CheckCircle size={14} /> : '1'}
          </div>
          <div className="flex-1 min-w-0">
            <p className="text-steam-text text-sm font-semibold">Sync top 100 games</p>
            <p className="text-steam-subtle text-xs mt-0.5 leading-relaxed">
              Downloads price history from IsThereAnyDeal for the 100 most popular Steam games. Runs in background (~1–2 min).
            </p>
          </div>
          <button
            onClick={handleSyncTop}
            disabled={step1Loading || step1Done}
            className={`flex-shrink-0 flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-mono transition-all disabled:opacity-60 ${step1Done ? 'bg-steam-green/10 text-steam-green border border-steam-green/20' : 'bg-steam-cyan/10 border border-steam-cyan/20 text-steam-cyan hover:bg-steam-cyan/20'}`}
          >
            {step1Loading && <RefreshCw size={11} className="animate-spin" />}
            {step1Done ? 'Started ✓' : 'Run Sync'}
          </button>
        </div>

        {/* Step 2 */}
        <div className="flex items-start gap-4 p-4 glass rounded-xl">
          <div className={`w-7 h-7 rounded-full flex items-center justify-center flex-shrink-0 text-xs font-bold mt-0.5 ${step2Done ? 'bg-steam-green/20 text-steam-green' : 'bg-steam-muted text-steam-subtle'}`}>
            {step2Done ? <CheckCircle size={14} /> : '2'}
          </div>
          <div className="flex-1 min-w-0">
            <p className="text-steam-text text-sm font-semibold">Generate ML predictions</p>
            <p className="text-steam-subtle text-xs mt-0.5 leading-relaxed">
              Runs the BUY/WAIT model on all synced games. Do this after step 1 finishes.
            </p>
          </div>
          <button
            onClick={handleGenPredictions}
            disabled={step2Loading || step2Done}
            className={`flex-shrink-0 flex items-center gap-2 px-3 py-2 rounded-lg text-xs font-mono transition-all disabled:opacity-60 ${step2Done ? 'bg-steam-green/10 text-steam-green border border-steam-green/20' : 'bg-steam-cyan/10 border border-steam-cyan/20 text-steam-cyan hover:bg-steam-cyan/20'}`}
          >
            {step2Loading && <RefreshCw size={11} className="animate-spin" />}
            {step2Done ? 'Started ✓' : 'Generate'}
          </button>
        </div>

        {/* Step 3 */}
        <div className="flex items-start gap-4 p-4 glass rounded-xl opacity-70">
          <div className="w-7 h-7 rounded-full flex items-center justify-center flex-shrink-0 text-xs font-bold mt-0.5 bg-steam-muted text-steam-subtle">3</div>
          <div className="flex-1 min-w-0">
            <p className="text-steam-text text-sm font-semibold">Refresh the page after ~2 min</p>
            <p className="text-steam-subtle text-xs mt-0.5 leading-relaxed">
              Come back after the background jobs finish. You'll see BUY signals, deals, and recommendations.
              You can also search any game manually — it auto-syncs price data on click.
            </p>
          </div>
        </div>
      </div>
    </div>
  )
}

// ── Library tab ───────────────────────────────────────────────────────────────

function LibraryTab({ token }: { token: string }) {
  const [data, setData]           = useState<any>(null)
  const [loading, setLoading]     = useState(true)
  const [syncing, setSyncing]     = useState(false)
  const [showSetup, setShowSetup] = useState(false)

  const load = useCallback(async () => {
    try {
      const d = await getLibrary(token)
      setData(d)
    } catch { } finally { setLoading(false) }
  }, [token])

  useEffect(() => { load() }, [load])

  const handleSync = async () => {
    setSyncing(true)
    try {
      await syncLibrary(token)
      await new Promise(r => setTimeout(r, 1500))
      const d = await getLibrary(token, true)
      setData(d)
    } catch { } finally { setSyncing(false) }
  }

  if (loading) return <LoadingSkeleton />

  const stats   = data?.stats || {}
  const games   = data?.games || []
  const tracked = games.filter((g: any) => g.game_id)

  return (
    <div className="space-y-6">

      {/* ── Stats row ────────────────────────────────────────────────────────── */}
      <div className="grid grid-cols-3 gap-4">
        {[
          { label: 'Total Games',   value: stats.total_games   || 0,         icon: Library  },
          { label: 'Hours Played',  value: `${stats.total_hours || 0}h`,     icon: Clock    },
          { label: 'Tracked in DB', value: stats.tracked_games || 0,         icon: Database },
        ].map(({ label, value, icon: Icon }) => (
          <div key={label} className="glass rounded-xl p-4 text-center">
            <Icon size={18} className="text-steam-cyan mx-auto mb-2" />
            <p className="font-display font-bold text-xl text-steam-text">{value}</p>
            <p className="text-steam-subtle text-xs mt-0.5">{label}</p>
          </div>
        ))}
      </div>

      {/* ── Actions ──────────────────────────────────────────────────────────── */}
      <div className="flex gap-3 flex-wrap">
        <button onClick={handleSync} disabled={syncing}
          className="flex items-center gap-2 px-4 py-2 glass rounded-xl text-sm font-mono text-steam-subtle hover:text-steam-text transition-all disabled:opacity-50">
          <RefreshCw size={14} className={syncing ? 'animate-spin text-steam-cyan' : ''} />
          {syncing ? 'Syncing...' : 'Sync with Steam'}
        </button>
        <button onClick={() => setShowSetup(v => !v)}
          className={`flex items-center gap-2 px-4 py-2 glass rounded-xl text-sm font-mono transition-all ${showSetup ? 'text-steam-amber border-steam-amber/30' : 'text-steam-subtle hover:text-steam-text'}`}>
          <Zap size={14} />
          Setup Guide
        </button>
      </div>

      {showSetup && <SetupGuide />}

      {/* ── Warning: importado pero sin datos ────────────────────────────────── */}
      {games.length > 0 && tracked.length === 0 && (
        <div className="glass rounded-xl px-5 py-4 border border-steam-amber/20 bg-steam-amber/5">
          <div className="flex items-start gap-3">
            <AlertTriangle size={15} className="text-steam-amber flex-shrink-0 mt-0.5" />
            <div>
              <p className="text-steam-amber text-sm font-semibold">Library imported — no price data yet</p>
              <p className="text-steam-subtle text-xs mt-1 leading-relaxed">
                Your {games.length} games are saved, but none have price history in the database.
                Use the <button onClick={() => setShowSetup(true)} className="text-steam-cyan underline">Setup Guide</button> above to populate it, or search individual games.
              </p>
            </div>
          </div>
        </div>
      )}

      {/* ── Profile Insights ─────────────────────────────────────────────────── */}
      {games.length > 0 && (
        <ProfileInsights games={games} />
      )}

      {/* ── Games list ───────────────────────────────────────────────────────── */}
      {games.length === 0 ? (
        <EmptyState msg="No library data yet. Click 'Sync with Steam' to import your games. Make sure your Steam profile is public." icon={Library} />
      ) : (
        <div className="space-y-2">
          <h3 className="text-steam-text text-sm font-semibold pt-2">All Games</h3>
          {games.map((g: any) => (
            <div key={g.appid}
              className="glass glass-hover rounded-xl flex items-center gap-4 px-4 py-3 group">

              {/* Image */}
              <div className="w-16 h-9 rounded-lg overflow-hidden bg-steam-muted flex-shrink-0">
                {steamImageUrl(g.appid) ? (
                  <img src={steamImageUrl(g.appid)!} alt={g.game_title} className="w-full h-full object-cover" />
                ) : (
                  <div className="w-full h-full bg-steam-muted" />
                )}
              </div>

              {/* Title + playtime */}
              <div className="flex-1 min-w-0">
                <p className="text-steam-text text-sm font-semibold truncate">{g.game_title}</p>
                <p className="text-steam-subtle text-xs font-mono">
                  {g.playtime_mins > 0
                    ? `${Math.round(g.playtime_mins / 60)}h played`
                    : 'Never played'}
                  {g.last_played && ` · last ${timeAgo(g.last_played)}`}
                </p>
              </div>

              {/* Price info */}
              {g.game_id ? (
                <div className="text-right flex-shrink-0">
                  <p className="text-steam-subtle text-xs font-mono">avg price</p>
                  <p className="text-steam-text text-sm font-mono font-semibold">{formatPrice(g.avg_price)}</p>
                </div>
              ) : (
                <span className="text-steam-subtle/40 text-xs font-mono flex-shrink-0">no data</span>
              )}

              {/* Link */}
              {g.game_id && (
                <Link href={`/game/${g.game_id}`}
                  className="flex-shrink-0 text-steam-subtle hover:text-steam-cyan transition-colors opacity-0 group-hover:opacity-100">
                  <ChevronRight size={16} />
                </Link>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

// ── Wishlist tab ──────────────────────────────────────────────────────────────

function WishlistTab({ token }: { token: string }) {
  const [data, setData]         = useState<any[]>([])
  const [loading, setLoading]   = useState(true)
  const [syncing, setSyncing]   = useState(false)
  const [syncMeta, setSyncMeta] = useState<any>(null)

  const load = useCallback(async () => {
    try {
      const d = await getWishlist(token)
      setData(d.wishlist || [])
    } catch { } finally { setLoading(false) }
  }, [token])

  useEffect(() => { load() }, [load])

  const handleSync = async () => {
    setSyncing(true)
    setSyncMeta(null)
    try {
      const d = await getWishlist(token, true)
      setData(d.wishlist || [])
      if (d.sync_meta) setSyncMeta(d.sync_meta)
    } catch { } finally { setSyncing(false) }
  }

  if (loading) return <LoadingSkeleton />

  const alerts = data.filter(g => g.discount_pct > 0 || g.signal === 'BUY')

  return (
    <div className="space-y-6">

      {/* Sync feedback */}
      {syncMeta && (
        <div className={`glass rounded-xl px-5 py-4 border ${
          syncMeta.private_profile
            ? 'border-red-500/30 bg-red-500/5'
            : syncMeta.error
            ? 'border-steam-amber/20 bg-steam-amber/5'
            : 'border-steam-green/20 bg-steam-green/5'
        }`}>
          <div className="flex items-start gap-3">
            {syncMeta.private_profile ? (
              <Lock size={15} className="text-red-400 flex-shrink-0 mt-0.5" />
            ) : syncMeta.error ? (
              <AlertTriangle size={15} className="text-steam-amber flex-shrink-0 mt-0.5" />
            ) : (
              <CheckCircle size={15} className="text-steam-green flex-shrink-0 mt-0.5" />
            )}
            <div className="flex-1">
              {syncMeta.private_profile ? (
                <>
                  <p className="text-red-400 text-sm font-semibold">Wishlist is private</p>
                  <p className="text-steam-subtle text-xs mt-1 leading-relaxed">
                    Go to Steam → your Profile → Edit Profile → Privacy Settings
                    → set <span className="text-steam-text font-semibold">"Game details"</span> to <span className="text-steam-text font-semibold">Public</span>.
                  </p>
                  <a href="https://store.steampowered.com/account/communityoptions"
                    target="_blank" rel="noopener noreferrer"
                    className="inline-flex items-center gap-1.5 mt-2 text-xs font-mono text-steam-cyan hover:underline">
                    Open Steam Privacy Settings <ExternalLink size={10} />
                  </a>
                </>
              ) : syncMeta.error ? (
                <>
                  <p className="text-steam-amber text-sm font-semibold">Sync issue</p>
                  <p className="text-steam-subtle text-xs mt-1">{syncMeta.error}</p>
                </>
              ) : (
                <>
                  <p className="text-steam-green text-sm font-semibold">
                    Wishlist synced — {syncMeta.items_found} items found
                  </p>
                  <p className="text-steam-subtle text-xs mt-1">
                    {syncMeta.items_imported} items imported. Price data loading in background.
                  </p>
                </>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Alerts banner */}
      {alerts.length > 0 && (
        <div className="glass rounded-xl px-5 py-4 border border-steam-amber/20 bg-steam-amber/5">
          <div className="flex items-center gap-2 mb-3">
            <AlertTriangle size={14} className="text-steam-amber" />
            <p className="text-steam-amber text-sm font-semibold">
              {alerts.length} wishlist item{alerts.length > 1 ? 's' : ''} worth checking
            </p>
          </div>
          <div className="flex flex-wrap gap-2">
            {alerts.map(g => (
              <Link key={g.appid} href={g.game_id ? `/game/${g.game_id}` : '#'}
                className="text-xs font-mono bg-steam-muted px-3 py-1.5 rounded-lg text-steam-text hover:text-steam-cyan transition-colors">
                {g.game_title} {g.discount_pct > 0 && `−${g.discount_pct}%`}
              </Link>
            ))}
          </div>
        </div>
      )}

      <div className="flex gap-3 flex-wrap">
        <button onClick={handleSync} disabled={syncing}
          className="flex items-center gap-2 px-4 py-2 glass rounded-xl text-sm font-mono text-steam-subtle hover:text-steam-text disabled:opacity-50 transition-all">
          <RefreshCw size={14} className={syncing ? 'animate-spin text-steam-cyan' : ''} />
          {syncing ? 'Syncing...' : 'Sync wishlist'}
        </button>
        {/* Alertas de precio via Notifications API */}
        {data.length > 0 && <PriceAlertButton wishlist={data} />}
      </div>

      {data.length === 0 ? (
        <EmptyState msg="No wishlist data. Click 'Sync wishlist' to import from Steam. Make sure your Steam profile privacy is set to Public." icon={Heart} />
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
          {data.map((g: any) => {
            const isOnSale = g.discount_pct > 0
            const isBuy    = g.signal === 'BUY'
            const isAtLow  = g.current_price > 0 && g.all_time_low > 0
                             && g.current_price <= g.all_time_low * 1.05
            return (
              <div key={g.appid} className={`glass glass-hover rounded-xl overflow-hidden group ${
                isBuy ? 'border-steam-green/20' : isOnSale ? 'border-steam-amber/20' : ''
              }`}>
                <div className="flex gap-3 p-4">
                  <div className="w-20 h-11 rounded-lg overflow-hidden bg-steam-muted flex-shrink-0">
                    {steamImageUrl(g.appid) && (
                      <img src={steamImageUrl(g.appid)!} alt={g.game_title} className="w-full h-full object-cover" />
                    )}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-steam-text text-sm font-semibold truncate">{g.game_title}</p>
                    <div className="flex items-center gap-2 mt-1 flex-wrap">
                      {g.current_price > 0 && (
                        <span className={`font-mono text-sm font-bold ${isOnSale ? 'text-steam-green' : 'text-steam-text'}`}>
                          {formatPrice(g.current_price)}
                        </span>
                      )}
                      {isOnSale && (
                        <span className="text-xs font-mono bg-steam-green/15 text-steam-green px-1.5 py-0.5 rounded">
                          −{g.discount_pct}%
                        </span>
                      )}
                      {isAtLow && (
                        <span className="text-xs font-mono bg-steam-cyan/10 text-steam-cyan px-1.5 py-0.5 rounded">ATL</span>
                      )}
                      {isBuy && (
                        <span className="text-xs font-mono bg-steam-green/10 text-steam-green px-1.5 py-0.5 rounded flex items-center gap-1">
                          <Zap size={9} /> BUY
                        </span>
                      )}
                    </div>
                    {g.all_time_low > 0 && (
                      <p className="text-steam-subtle text-xs font-mono mt-1">
                        ATL {formatPrice(g.all_time_low)}
                      </p>
                    )}
                  </div>
                  {g.game_id && (
                    <Link href={`/game/${g.game_id}`}
                      className="flex-shrink-0 text-steam-subtle hover:text-steam-cyan opacity-0 group-hover:opacity-100 transition-all self-center">
                      <ChevronRight size={16} />
                    </Link>
                  )}
                </div>
              </div>
            )
          })}
        </div>
      )}
    </div>
  )
}

// ── Recommendations tab ───────────────────────────────────────────────────────

function RecsTab({ token }: { token: string }) {
  const [recs, setRecs]       = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    getRecommendations(token, 24)
      .then(d => setRecs(d.recommendations || []))
      .catch(() => {})
      .finally(() => setLoading(false))
  }, [token])

  if (loading) return <LoadingSkeleton />

  if (!recs.length) return (
    <div className="space-y-4">
      <EmptyState
        msg="No recommendations yet. Sync your library and populate the database so the model can generate BUY signals."
        icon={Sparkles}
      />
      <div className="glass rounded-xl px-5 py-4 border border-steam-cyan/20">
        <p className="text-steam-cyan text-sm font-semibold flex items-center gap-2 mb-3">
          <Zap size={13} /> How to get recommendations
        </p>
        <ol className="text-steam-subtle text-xs space-y-2 list-decimal list-inside leading-relaxed">
          <li>Go to <span className="text-steam-text">Library</span> tab → click <span className="text-steam-text">"Setup Guide"</span></li>
          <li>Run <span className="text-steam-text">"Run Sync"</span> to download price history for 100 games</li>
          <li>Run <span className="text-steam-text">"Generate"</span> to create BUY/WAIT predictions</li>
          <li>Come back here after ~2 min — you'll see games you don't own worth buying</li>
        </ol>
      </div>
    </div>
  )

  return (
    <div className="space-y-4">
      <p className="text-steam-subtle text-sm">
        Games you <span className="text-steam-text">don't own</span> that our ML model says are worth buying right now.
      </p>
      <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
        {recs.map((r: any, i: number) => (
          <GameCard key={r.id} id={r.id} title={r.title} appid={r.appid}
            currentPrice={r.current_price} discountPct={r.discount_pct}
            score={r.score} signal={r.signal} minPrice={r.min_price} index={i} />
        ))}
      </div>
    </div>
  )
}

// ── Helpers ───────────────────────────────────────────────────────────────────

function LoadingSkeleton() {
  return (
    <div className="space-y-3">
      {[1, 2, 3, 4].map(i => (
        <div key={i} className="glass rounded-xl h-16 animate-pulse shimmer" />
      ))}
    </div>
  )
}

function EmptyState({ msg, icon: Icon }: { msg: string; icon: any }) {
  return (
    <div className="text-center py-16 space-y-3">
      <Icon size={32} className="text-steam-subtle/40 mx-auto" />
      <p className="text-steam-subtle text-sm max-w-sm mx-auto">{msg}</p>
    </div>
  )
}

// ── Page ──────────────────────────────────────────────────────────────────────

export default function DashboardPage() {
  const searchParams = useSearchParams()
  const router       = useRouter()
  const [user, setUser]   = useState<SteamUser | null>(null)
  const [token, setToken] = useState<string | null>(null)
  const [tab, setTab]     = useState<Tab>('library')

  useEffect(() => {
    // Handle token from Steam callback
    const urlToken = searchParams.get('token')
    if (urlToken) {
      localStorage.setItem('steamsense_token', urlToken)
      router.replace('/dashboard')
    }

    const t = getToken()
    const u = getUserFromStorage()
    setToken(t)
    setUser(u)

    // Tab from URL
    const tabParam = searchParams.get('tab') as Tab | null
    if (tabParam && ['library', 'wishlist', 'recs'].includes(tabParam)) {
      setTab(tabParam)
    }
  }, [searchParams, router])

  const tabs: { key: Tab; label: string; icon: any }[] = [
    { key: 'library',  label: 'Library',         icon: Library  },
    { key: 'wishlist', label: 'Wishlist',         icon: Heart    },
    { key: 'recs',     label: 'Recommendations',  icon: Sparkles },
  ]

  return (
    <div className="min-h-screen bg-steam-bg">
      <Navbar />
      <div className="max-w-4xl mx-auto px-6 pt-24 pb-20">

        {/* Header */}
        <div className="mb-8">
          {user && (
            <div className="flex items-center gap-4 mb-6">
              {user.avatar_url && (
                <Image src={user.avatar_url} alt={user.display_name}
                  width={48} height={48} className="rounded-full" unoptimized />
              )}
              <div>
                <h1 className="font-display font-bold text-2xl text-steam-text">{user.display_name}</h1>
                <p className="text-steam-subtle text-xs font-mono">Steam ID: {user.steam_id}</p>
              </div>
            </div>
          )}

          {/* Tabs */}
          <div className="flex gap-2 flex-wrap">
            {tabs.map(({ key, label, icon: Icon }) => (
              <button key={key} onClick={() => setTab(key)}
                className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-mono transition-all ${
                  tab === key
                    ? 'bg-steam-cyan/10 border border-steam-cyan/30 text-steam-cyan'
                    : 'glass text-steam-subtle hover:text-steam-text'
                }`}>
                <Icon size={14} />
                {label}
              </button>
            ))}
          </div>
        </div>

        {/* Content */}
        {!token ? (
          <div className="text-center py-20 space-y-4">
            <p className="text-steam-subtle">Please sign in with Steam to view your dashboard.</p>
            <a href={`${BASE}/auth/steam`}
              className="inline-flex items-center gap-2 px-5 py-2.5 bg-steam-cyan/10 border border-steam-cyan/20 text-steam-cyan rounded-xl text-sm font-mono hover:bg-steam-cyan/20 transition-all">
              Sign in with Steam
            </a>
          </div>
        ) : (
          <>
            {tab === 'library'  && <LibraryTab  token={token} />}
            {tab === 'wishlist' && <WishlistTab token={token} />}
            {tab === 'recs'     && <RecsTab     token={token} />}
          </>
        )}
      </div>
    </div>
  )
}

============================================================
ARCHIVO: frontend\src\app\explore\page.tsx
LINEAS: 255
============================================================

'use client'

import { useState, useEffect, useTransition } from 'react'
import { Compass, Zap, TrendingDown, Database, RefreshCw, AlertCircle } from 'lucide-react'
import Link from 'next/link'
import Navbar from '@/components/Navbar'
import GameCard from '@/components/GameCard'
import { getTopDeals, getTopBuySignals, listGames } from '@/lib/api'

const BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'

type Tab = 'deals' | 'buy' | 'all'

function GridSkeleton() {
  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
      {Array.from({ length: 15 }).map((_, i) => (
        <div key={i} className="glass rounded-2xl overflow-hidden animate-pulse">
          <div className="h-28 bg-steam-muted" />
          <div className="p-3 space-y-2">
            <div className="h-3 bg-steam-muted rounded w-3/4" />
            <div className="h-2 bg-steam-muted rounded w-1/2" />
          </div>
        </div>
      ))}
    </div>
  )
}

function EmptyTabState({ tab, onGenerate }: { tab: Tab; onGenerate: () => void }) {
  const msgs = {
    deals: 'No deals yet — games need price history with discounts.',
    buy:   'No BUY signals yet — predictions are generated from price history.',
    all:   'No games synced yet.',
  }
  const tips = {
    deals: 'Run a sync first, then come back here.',
    buy:   'Try "Generate Predictions" to run ML on all synced games.',
    all:   'Use the search bar to find and sync individual games.',
  }
  return (
    <div className="py-20 text-center space-y-4">
      <Database size={36} className="text-steam-subtle/30 mx-auto" />
      <div>
        <p className="text-steam-text text-sm">{msgs[tab]}</p>
        <p className="text-steam-subtle text-xs mt-1">{tips[tab]}</p>
      </div>
      {tab === 'buy' && (
        <button onClick={onGenerate}
          className="inline-flex items-center gap-2 px-4 py-2 bg-steam-green/10 border border-steam-green/30 rounded-xl text-steam-green text-sm font-mono hover:bg-steam-green/20 transition-all">
          <Zap size={13} /> Generate Predictions
        </button>
      )}
      {tab === 'deals' && (
        <Link href="/"
          className="inline-flex items-center gap-2 px-4 py-2 glass rounded-xl text-steam-cyan text-sm font-mono hover:bg-steam-muted transition-all">
          Go to Home & Sync Games
        </Link>
      )}
    </div>
  )
}

export default function ExplorePage() {
  const [tab, setTab]         = useState<Tab>('deals')
  const [deals, setDeals]     = useState<any[]>([])
  const [signals, setSignals] = useState<any[]>([])
  const [games, setGames]     = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [genMsg, setGenMsg]   = useState<string | null>(null)
  const [isPending, startTransition] = useTransition()

  // FIX: contadores precargados para todos los tabs, no solo el activo
  const [counts, setCounts] = useState<Record<Tab, number | null>>({
    deals: null,
    buy:   null,
    all:   null,
  })

  // Carga el tab activo con datos completos
  const loadTab = async (t: Tab) => {
    setLoading(true)
    try {
      if (t === 'deals') {
        const data = await getTopDeals(60)
        setDeals(data)
        setCounts(c => ({ ...c, deals: data.length }))
      } else if (t === 'buy') {
        const data = await getTopBuySignals(60)
        setSignals(data)
        setCounts(c => ({ ...c, buy: data.length }))
      } else {
        const data = await listGames(200)
        setGames(data)
        setCounts(c => ({ ...c, all: data.length }))
      }
    } catch (e) {
      console.error(e)
    } finally {
      setLoading(false)
    }
  }

  // Al montar: carga el tab activo + prefetch de contadores de los otros dos en paralelo
  useEffect(() => {
    loadTab('deals')

    // Prefetch contadores en background — requests ligeras con limit pequeño
    Promise.allSettled([
      getTopBuySignals(60).then(d => setCounts(c => ({ ...c, buy:   d.length }))),
      listGames(200).then(d      => setCounts(c => ({ ...c, all:   d.length }))),
    ])
  }, [])

  const handleTabChange = (t: Tab) => {
    setTab(t)
    loadTab(t)
  }

  const handleGeneratePredictions = async () => {
    setGenMsg('Generating predictions...')
    try {
      await fetch(`${BASE}/sync/predictions`, { method: 'POST' })
      setGenMsg('Running in background. Refresh in ~30 seconds.')
      setTimeout(async () => {
        const data = await getTopBuySignals(60)
        setSignals(data)
        setCounts(c => ({ ...c, buy: data.length }))
        setGenMsg(null)
      }, 8000)
    } catch {
      setGenMsg('Error starting prediction batch.')
      setTimeout(() => setGenMsg(null), 3000)
    }
  }

  const handleRefresh = () => {
    startTransition(() => { loadTab(tab) })
  }

  const currentData = tab === 'deals' ? deals : tab === 'buy' ? signals : games
  const isEmpty     = !loading && currentData.length === 0

  const tabs: { key: Tab; label: string; icon: typeof Zap; color?: string }[] = [
    { key: 'deals', label: 'Hot Deals',   icon: TrendingDown },
    { key: 'buy',   label: 'BUY Signals', icon: Zap,         color: 'text-steam-green' },
    { key: 'all',   label: 'All Games',   icon: Database },
  ]

  return (
    <div className="min-h-screen bg-steam-bg">
      <Navbar />
      <div className="max-w-7xl mx-auto px-6 pt-24 pb-20">

        {/* Header */}
        <div className="flex items-start justify-between mb-8">
          <div>
            <div className="flex items-center gap-3 mb-1">
              <div className="w-8 h-8 rounded-lg bg-steam-cyan/10 border border-steam-cyan/20 flex items-center justify-center">
                <Compass size={16} className="text-steam-cyan" />
              </div>
              <h1 className="font-display font-bold text-2xl text-steam-text">Explore</h1>
            </div>
            <p className="text-steam-subtle text-sm">Browse all tracked games and find the best deals</p>
          </div>

          {/* Actions */}
          <div className="flex items-center gap-2 flex-shrink-0">
            {tab === 'buy' && (
              <button onClick={handleGeneratePredictions}
                className="flex items-center gap-2 px-3 py-2 glass rounded-xl text-xs font-mono text-steam-green hover:bg-steam-green/10 transition-all">
                <Zap size={12} /> Generate
              </button>
            )}
            <button onClick={handleRefresh} disabled={loading || isPending}
              className="flex items-center gap-2 px-3 py-2 glass rounded-xl text-xs font-mono text-steam-subtle hover:text-steam-text transition-all disabled:opacity-40">
              <RefreshCw size={12} className={loading ? 'animate-spin' : ''} /> Refresh
            </button>
          </div>
        </div>

        {/* Gen message */}
        {genMsg && (
          <div className="flex items-center gap-2 px-4 py-3 glass rounded-xl border border-steam-green/20 text-steam-green text-sm font-mono mb-6">
            <AlertCircle size={14} /> {genMsg}
          </div>
        )}

        {/* Tabs — FIX: contador visible en TODOS los tabs, no solo el activo */}
        <div className="flex items-center gap-2 mb-8">
          {tabs.map(({ key, label, icon: Icon, color }) => {
            const isActive = tab === key
            const count    = counts[key]
            return (
              <button key={key} onClick={() => handleTabChange(key)}
                className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-mono transition-all ${
                  isActive
                    ? 'bg-steam-cyan/10 border border-steam-cyan/30 text-steam-cyan'
                    : 'glass text-steam-subtle hover:text-steam-text'
                }`}>
                <Icon size={14} className={!isActive && color ? color : undefined} />
                {label}
                {/* Contador siempre visible si hay datos, con opacidad reducida si no es el tab activo */}
                {count !== null && count > 0 && (
                  <span className={`text-xs px-1.5 py-0.5 rounded-full font-mono transition-all ${
                    isActive
                      ? 'bg-steam-cyan/20 text-steam-cyan'
                      : 'bg-steam-muted text-steam-subtle'
                  }`}>
                    {count}
                  </span>
                )}
                {/* Spinner mini mientras carga ese tab en bg */}
                {count === null && !isActive && (
                  <span className="w-3 h-3 rounded-full border border-steam-subtle/30 border-t-steam-subtle animate-spin inline-block" />
                )}
              </button>
            )
          })}
        </div>

        {/* Content */}
        {loading ? (
          <GridSkeleton />
        ) : isEmpty ? (
          <EmptyTabState tab={tab} onGenerate={handleGeneratePredictions} />
        ) : tab === 'deals' ? (
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
            {deals.map((d: any, i: number) => (
              <GameCard key={d.id} id={d.id} title={d.title} appid={d.appid}
                currentPrice={d.current_price} regularPrice={d.regular_price}
                discountPct={d.discount_pct} minPrice={d.min_price}
                lastSeen={d.last_seen} index={i} />
            ))}
          </div>
        ) : tab === 'buy' ? (
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
            {signals.map((s: any, i: number) => (
              <GameCard key={s.id} id={s.id} title={s.title} appid={s.appid}
                currentPrice={s.current_price} discountPct={s.discount_pct}
                score={s.score} signal={s.signal} index={i} />
            ))}
          </div>
        ) : (
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
            {games.map((g: any, i: number) => (
              <GameCard key={g.id} id={g.id} title={g.title} appid={g.appid}
                minPrice={g.min_price} discountPct={g.max_discount} index={i} />
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

============================================================
ARCHIVO: frontend\src\app\game\[id]\page.tsx
LINEAS: 174
============================================================

import { Suspense } from 'react'
import { notFound } from 'next/navigation'
import Link from 'next/link'
import { ArrowLeft, RefreshCw, ExternalLink, BarChart3, Clock } from 'lucide-react'
import Navbar from '@/components/Navbar'
import PredictionBadge from '@/components/PredictionBadge'
import PriceChart from '@/components/PriceChart'
import SeasonalChart from '@/components/SeasonalChart'
import { getGameStats, getPriceHistory, getPrediction } from '@/lib/api'
import { formatDate, formatPrice } from '@/lib/utils'

interface Props { params: { id: string } }

function StatCard({ label, value, sub }: { label: string; value: string; sub?: string }) {
  return (
    <div className="glass rounded-xl p-4 text-center">
      <div className="text-steam-text font-mono font-semibold text-base">{value}</div>
      <div className="text-steam-subtle text-xs mt-0.5">{label}</div>
      {sub && <div className="text-steam-subtle/60 text-xs mt-0.5 font-mono">{sub}</div>}
    </div>
  )
}

export default async function GamePage({ params }: Props) {
  const { id } = params

  const [statsResult, historyResult, predictionResult] = await Promise.allSettled([
    getGameStats(id),
    getPriceHistory(id),
    getPrediction(id),
  ])

  // If game doesn't exist at all in DB → 404
  if (statsResult.status === 'rejected') {
    const msg = (statsResult.reason as Error)?.message || ''
    // Show friendly page if it's a "not found" vs a server error
    if (msg.includes('404') || msg.toLowerCase().includes('not found')) {
      return (
        <div className="min-h-screen bg-steam-bg flex items-center justify-center px-6">
          <div className="text-center space-y-6 max-w-md">
            <div className="w-20 h-20 mx-auto rounded-2xl bg-steam-card border border-steam-border flex items-center justify-center">
              <Clock size={36} className="text-steam-cyan animate-pulse-slow" />
            </div>
            <div>
              <h1 className="font-display font-bold text-2xl text-steam-text">Loading price data...</h1>
              <p className="text-steam-subtle mt-2 text-sm leading-relaxed">
                This game is being synced from IsThereAnyDeal.
                It might take a few seconds. Refresh in a moment.
              </p>
            </div>
            <div className="flex gap-3 justify-center">
              <button
                onClick={() => window.location.reload()}
                className="inline-flex items-center gap-2 px-5 py-2.5 bg-steam-cyan/10 border border-steam-cyan/20 text-steam-cyan rounded-xl text-sm font-mono hover:bg-steam-cyan/20 transition-colors"
              >
                <RefreshCw size={14} /> Refresh
              </button>
              <Link
                href="/"
                className="inline-flex items-center gap-2 px-5 py-2.5 glass border border-steam-border text-steam-subtle rounded-xl text-sm font-mono hover:text-steam-text transition-colors"
              >
                <ArrowLeft size={14} /> Back
              </Link>
            </div>
          </div>
        </div>
      )
    }
    notFound()
  }

  const stats = statsResult.value
  const history = historyResult.status === 'fulfilled' ? historyResult.value : null
  const prediction = predictionResult.status === 'fulfilled' ? predictionResult.value : null
  const steamUrl = stats.appid ? `https://store.steampowered.com/app/${stats.appid}` : null

  return (
    <div className="min-h-screen bg-steam-bg">
      <Navbar />
      <div className="max-w-6xl mx-auto px-6 pt-20 pb-20">

        <Link href="/" className="inline-flex items-center gap-2 text-steam-subtle text-sm hover:text-steam-text transition-colors mt-6 mb-8 font-mono">
          <ArrowLeft size={14} /> Back to search
        </Link>

        {/* Title */}
        <div className="flex items-start justify-between gap-4 mb-8">
          <div>
            <h1 className="font-display font-bold text-3xl sm:text-4xl text-steam-text leading-tight">
              {stats.title}
            </h1>
            {stats.appid && (
              <p className="text-steam-subtle text-sm font-mono mt-1">Steam App ID: {stats.appid}</p>
            )}
          </div>
          {steamUrl && (
            <a href={steamUrl} target="_blank" rel="noopener noreferrer"
              className="flex items-center gap-1.5 px-3 py-2 glass rounded-lg text-steam-subtle hover:text-steam-text text-xs font-mono transition-colors flex-shrink-0">
              <ExternalLink size={12} /> Steam
            </a>
          )}
        </div>

        {/* Main grid */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">

          {/* Left: prediction + stats */}
          <div className="lg:col-span-1 space-y-6">
            {prediction
              ? <PredictionBadge data={prediction} />
              : (
                <div className="glass rounded-2xl p-6 text-center space-y-3">
                  <BarChart3 size={32} className="text-steam-subtle mx-auto" />
                  <p className="text-steam-subtle text-sm">
                    {predictionResult.status === 'rejected'
                      ? 'Need more price history for a prediction.'
                      : 'Generating prediction...'}
                  </p>
                </div>
              )
            }

            {stats.stats && (
              <div className="space-y-3">
                <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest">Price Stats</p>
                <div className="grid grid-cols-2 gap-2">
                  <StatCard label="All-time low"  value={formatPrice(stats.stats.min_price)} />
                  <StatCard label="All-time high" value={formatPrice(stats.stats.max_price)} />
                  <StatCard label="Average price" value={formatPrice(stats.stats.avg_price)} />
                  <StatCard label="Max discount"  value={`${stats.stats.max_discount ?? 0}%`} />
                  <StatCard label="Avg on-sale"   value={`${stats.stats.avg_discount_when_on_sale?.toFixed(1) ?? '—'}%`} />
                  <StatCard label="Data points"   value={stats.stats.total_records?.toLocaleString() ?? '—'} />
                </div>
                {stats.stats.first_seen && (
                  <div className="glass rounded-xl px-4 py-3 text-xs text-steam-subtle font-mono">
                    Tracked since <span className="text-steam-text">{formatDate(stats.stats.first_seen)}</span>
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Right: charts */}
          <div className="lg:col-span-2 space-y-6">
            {history
              ? <PriceChart history={history.history} stats={stats.stats} />
              : (
                <div className="glass rounded-2xl p-8 text-center text-steam-subtle">
                  <p className="text-sm">No price history available yet.</p>
                </div>
              )
            }
            {stats.seasonal_patterns?.length > 0 && (
              <SeasonalChart patterns={stats.seasonal_patterns} />
            )}
            <div className="glass rounded-xl px-5 py-4 flex items-center justify-between">
              <div>
                <p className="text-steam-text text-sm font-semibold">Refresh price data</p>
                <p className="text-steam-subtle text-xs font-mono mt-0.5">
                  Last updated: {stats.stats?.last_seen ? formatDate(stats.stats.last_seen) : '—'}
                </p>
              </div>
              {stats.appid && (
                <code className="text-steam-subtle/60 text-xs font-mono">
                  POST /sync/game/{stats.appid}
                </code>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\EmptyStateWithSeed.tsx
LINEAS: 96
============================================================

'use client'

import { useState } from 'react'
import Link from 'next/link'
import { Search, Zap, TrendingDown, RefreshCw } from 'lucide-react'

// Popular Steam games to suggest when DB is empty
const SEED_GAMES = [
  { title: 'Elden Ring',           appid: 1245620, hint: 'Usually 20-40% off during sales' },
  { title: 'Cyberpunk 2077',       appid: 1091500, hint: 'Frequent deep discounts up to 75%' },
  { title: 'Stardew Valley',       appid: 413150,  hint: 'Rarely goes above 50% off, but worth it' },
  { title: 'Red Dead Redemption 2',appid: 1174180, hint: 'Historically 60-75% off in major sales' },
  { title: 'Hades',                appid: 1145360, hint: 'Regularly 50% off during Steam sales' },
  { title: 'Baldur\'s Gate 3',     appid: 1086940, hint: 'Still relatively new, small discounts' },
  { title: 'Deep Rock Galactic',   appid: 548430,  hint: 'Hits 75% off during seasonal sales' },
  { title: 'Monster Hunter: World',appid: 582010,  hint: 'Extremely cheap during sales (-80%)' },
]

interface Props {
  onSearch?: (query: string) => void
}

export default function EmptyStateWithSeed({ onSearch }: Props) {
  const [syncing, setSyncing] = useState<string | null>(null)

  const handleSync = async (appid: number, title: string) => {
    setSyncing(title)
    try {
      const res = await fetch(`http://localhost:8000/sync/game/${appid}`, { method: 'POST' })
      const data = await res.json()
      if (data.game_id) {
        window.location.href = `/game/${data.game_id}`
      }
    } catch (e) {
      setSyncing(null)
    }
  }

  return (
    <div className="space-y-6 py-4">
      {/* CTA row */}
      <div className="flex items-center gap-3 flex-wrap">
        <div className="flex items-center gap-2 px-3 py-2 glass rounded-xl border border-steam-amber/20 text-steam-amber text-xs font-mono">
          <Zap size={12} />
          Sync games to see deals & predictions
        </div>
        <code className="text-steam-subtle/50 text-xs font-mono hidden sm:block">
          POST /sync/top?top_n=50
        </code>
      </div>

      {/* Suggested games grid */}
      <div>
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest mb-3">
          Popular Games · Click to Load
        </p>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
          {SEED_GAMES.map(g => (
            <button
              key={g.appid}
              onClick={() => handleSync(g.appid, g.title)}
              disabled={syncing !== null}
              className="glass glass-hover rounded-xl overflow-hidden text-left group disabled:opacity-60 transition-all"
            >
              {/* Steam header image */}
              <div className="relative h-16 overflow-hidden bg-steam-muted">
                <img
                  src={`https://cdn.akamai.steamstatic.com/steam/apps/${g.appid}/header.jpg`}
                  alt={g.title}
                  className="w-full h-full object-cover opacity-80 group-hover:opacity-100 group-hover:scale-105 transition-all duration-300"
                  onError={e => { (e.target as HTMLImageElement).style.display = 'none' }}
                />
                {syncing === g.title && (
                  <div className="absolute inset-0 bg-steam-bg/80 flex items-center justify-center">
                    <RefreshCw size={16} className="text-steam-cyan animate-spin" />
                  </div>
                )}
              </div>
              <div className="p-3">
                <p className="text-steam-text text-xs font-semibold leading-tight">{g.title}</p>
                <p className="text-steam-subtle/60 text-xs font-mono mt-1 leading-tight">{g.hint}</p>
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Or search */}
      <div className="text-center">
        <p className="text-steam-subtle/50 text-xs font-mono">
          or use the search bar above to find any Steam game
        </p>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\GameCard.tsx
LINEAS: 131
============================================================

import Link from 'next/link'
import Image from 'next/image'
import { TrendingDown, Clock, ChevronRight } from 'lucide-react'
import { formatPrice, steamImageUrl, discountBg, timeAgo } from '@/lib/utils'

interface Props {
  id: string
  title: string
  appid?: number | null
  currentPrice?: number | null
  regularPrice?: number | null
  discountPct?: number | null
  minPrice?: number | null
  score?: number | null
  signal?: string | null
  reason?: string | null
  lastSeen?: string | null
  index?: number
}

export default function GameCard({
  id, title, appid, currentPrice, regularPrice, discountPct,
  minPrice, score, signal, reason, lastSeen, index = 0
}: Props) {
  const img = steamImageUrl(appid)
  const hasDeal = (discountPct ?? 0) > 0
  const isNearLow = minPrice != null && currentPrice != null && currentPrice <= minPrice * 1.05

  return (
    <Link
      href={`/game/${id}`}
      className="glass glass-hover rounded-2xl overflow-hidden group block animate-slide-up"
      style={{ animationDelay: `${index * 40}ms`, animationFillMode: 'both' }}
    >
      {/* Game image */}
      <div className="relative h-32 bg-steam-muted overflow-hidden">
        {img ? (
          <Image
            src={img} alt={title}
            fill className="object-cover group-hover:scale-105 transition-transform duration-500"
            unoptimized
          />
        ) : (
          <div className="absolute inset-0 bg-gradient-to-br from-steam-muted to-steam-card flex items-center justify-center">
            <span className="text-steam-subtle/40 text-4xl font-display font-bold">
              {title.charAt(0)}
            </span>
          </div>
        )}
        {/* Overlay gradient */}
        <div className="absolute inset-0 bg-gradient-to-t from-steam-card/90 via-transparent to-transparent" />

        {/* Discount badge */}
        {hasDeal && discountPct != null && (
          <div className={`absolute top-2 right-2 px-2 py-0.5 rounded-lg text-xs font-mono font-bold border ${discountBg(discountPct)}`}>
            −{discountPct}%
          </div>
        )}

        {/* Near all-time low badge */}
        {isNearLow && (
          <div className="absolute top-2 left-2 px-2 py-0.5 rounded-lg text-xs font-mono bg-steam-green/20 border border-steam-green/40 text-steam-green flex items-center gap-1">
            <TrendingDown size={10} /> ATL
          </div>
        )}

        {/* Signal badge */}
        {signal && (
          <div className={`absolute bottom-2 left-2 px-2 py-0.5 rounded-lg text-xs font-mono font-bold ${
            signal === 'BUY'
              ? 'bg-steam-green/20 border border-steam-green/40 text-steam-green'
              : 'bg-steam-amber/20 border border-steam-amber/40 text-steam-amber'
          }`}>
            {signal}
          </div>
        )}
      </div>

      {/* Content */}
      <div className="p-4 space-y-2">
        <div className="flex items-start justify-between gap-2">
          <h3 className="text-steam-text text-sm font-semibold leading-snug line-clamp-2 group-hover:text-steam-cyan transition-colors flex-1">
            {title}
          </h3>
          <ChevronRight size={14} className="text-steam-subtle group-hover:text-steam-cyan transition-colors flex-shrink-0 mt-0.5" />
        </div>

        {/* Price row */}
        {currentPrice !== undefined && currentPrice !== null && (
          <div className="flex items-center gap-2">
            <span className={`font-mono font-bold text-sm ${hasDeal ? 'text-steam-green' : 'text-steam-text'}`}>
              {formatPrice(currentPrice)}
            </span>
            {hasDeal && regularPrice != null && regularPrice !== currentPrice && (
              <span className="text-steam-subtle/60 text-xs font-mono line-through">
                {formatPrice(regularPrice)}
              </span>
            )}
          </div>
        )}

        {/* Score bar */}
        {score != null && (
          <div className="space-y-1">
            <div className="flex justify-between text-xs">
              <span className="text-steam-subtle font-mono">ML Score</span>
              <span className={`font-mono font-semibold ${score >= 70 ? 'text-steam-green' : score >= 50 ? 'text-steam-amber' : 'text-steam-red'}`}>
                {Math.round(score)}
              </span>
            </div>
            <div className="h-1 bg-steam-muted rounded-full overflow-hidden">
              <div
                className={`h-full rounded-full transition-all duration-700 ${
                  score >= 70 ? 'bg-steam-green' : score >= 50 ? 'bg-steam-amber' : 'bg-steam-red'
                }`}
                style={{ width: `${score}%` }}
              />
            </div>
          </div>
        )}

        {lastSeen && (
          <div className="flex items-center gap-1 text-steam-subtle/60 text-xs font-mono">
            <Clock size={9} />
            {timeAgo(lastSeen)}
          </div>
        )}
      </div>
    </Link>
  )
}


============================================================
ARCHIVO: frontend\src\components\GameSearch.tsx
LINEAS: 175
============================================================

'use client'

import { useState, useEffect, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { Search, Loader2, Gamepad2, RefreshCw } from 'lucide-react'
import { searchGames, syncByGameId } from '@/lib/api'
import { steamImageUrl } from '@/lib/utils'
import type { SearchResult } from '@/lib/types'

export default function GameSearch() {
  const [query, setQuery]     = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [loading, setLoading] = useState(false)
  const [syncing, setSyncing] = useState<string | null>(null)
  const [open, setOpen]       = useState(false)
  const [error, setError]     = useState('')
  const debounce   = useRef<ReturnType<typeof setTimeout>>(null)
  const router     = useRouter()
  const wrapperRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const handleClick = (e: MouseEvent) => {
      if (wrapperRef.current && !wrapperRef.current.contains(e.target as Node))
        setOpen(false)
    }
    document.addEventListener('mousedown', handleClick)
    return () => document.removeEventListener('mousedown', handleClick)
  }, [])

  useEffect(() => {
    if (debounce.current) clearTimeout(debounce.current)
    if (!query.trim() || query.length < 2) {
      setResults([])
      setOpen(false)
      return
    }
    debounce.current = setTimeout(async () => {
      setLoading(true)
      setError('')
      try {
        const data = await searchGames(query)
        setResults(data.slice(0, 8))
        setOpen(data.length > 0)
      } catch {
        setError('Backend not connected. Start the FastAPI server.')
        setOpen(false)
      } finally {
        setLoading(false)
      }
    }, 350)
  }, [query])

  const handleSelect = async (game: SearchResult) => {
    setOpen(false)
    setQuery('')
    setSyncing(game.id)
    try {
      await syncByGameId(game.id)
    } catch {
      // Even if sync fails, try navigating — maybe it's already in DB
    } finally {
      setSyncing(null)
    }
    router.push(`/game/${game.id}`)
  }

  return (
    <div ref={wrapperRef} className="relative w-full max-w-2xl mx-auto">
      {/* Input */}
      <div className="relative">
        <div className="absolute left-4 top-1/2 -translate-y-1/2 text-steam-subtle">
          {loading
            ? <Loader2 size={18} className="animate-spin text-steam-cyan" />
            : <Search size={18} />
          }
        </div>
        <input
          value={query}
          onChange={e => setQuery(e.target.value)}
          onFocus={() => results.length > 0 && setOpen(true)}
          placeholder="Search any Steam game..."
          className="
            w-full pl-12 pr-4 py-4
            bg-steam-card border border-steam-border
            rounded-xl text-steam-text placeholder-steam-subtle
            font-body text-base
            focus:outline-none focus:border-steam-cyan focus:ring-1 focus:ring-steam-cyan/30
            transition-all duration-200
          "
        />
        {query && (
          <button
            onClick={() => { setQuery(''); setResults([]); setOpen(false) }}
            className="absolute right-4 top-1/2 -translate-y-1/2 text-steam-subtle hover:text-steam-text transition-colors"
          >✕</button>
        )}
      </div>

      {/* Syncing overlay */}
      {syncing && (
        <div className="mt-2 px-4 py-2.5 bg-steam-cyan/10 border border-steam-cyan/20 rounded-lg flex items-center gap-2 text-steam-cyan text-sm">
          <RefreshCw size={13} className="animate-spin" />
          Loading price data...
        </div>
      )}

      {/* Error */}
      {error && (
        <div className="mt-2 px-4 py-2 bg-steam-red/10 border border-steam-red/20 rounded-lg text-steam-red text-sm">
          {error}
        </div>
      )}

      {/* Dropdown */}
      {open && results.length > 0 && !syncing && (
        <div className="
          absolute z-50 w-full mt-4
          bg-steam-card border border-steam-border
          rounded-xl overflow-y-auto max-h-72
          shadow-2xl shadow-black/50
          animate-fade-in
        ">
          {results.map((game) => {
            // ITAD search results no traen appid directamente,
            // pero el slug a veces contiene el nombre que podemos usar para el fallback.
            // Si en el futuro el backend devuelve appid en search, esto lo tomará automáticamente.
            const appid = (game as any).appid ?? null
            const img   = steamImageUrl(appid, 'capsule')

            return (
              <button
                key={game.id}
                onClick={() => handleSelect(game)}
                className="
                  w-full flex items-center gap-3 px-3 py-2.5
                  hover:bg-steam-muted
                  border-b border-steam-border last:border-0
                  transition-colors text-left group
                "
              >
                {/* Thumbnail */}
                <div className="w-16 h-9 rounded-lg overflow-hidden bg-steam-muted flex-shrink-0 flex items-center justify-center">
                  {img ? (
                    <img
                      src={img}
                      alt={game.title}
                      className="w-full h-full object-cover"
                      onError={e => { (e.target as HTMLImageElement).style.display = 'none' }}
                    />
                  ) : (
                    <Gamepad2 size={14} className="text-steam-subtle group-hover:text-steam-cyan transition-colors" />
                  )}
                </div>

                {/* Title + type */}
                <div className="flex-1 min-w-0">
                  <div className="text-steam-text text-sm font-medium truncate group-hover:text-steam-cyan transition-colors">
                    {game.title}
                  </div>
                  {game.type && (
                    <div className="text-steam-subtle text-xs capitalize">{game.type}</div>
                  )}
                </div>

                <div className="text-steam-subtle text-xs font-mono opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0">
                  →
                </div>
              </button>
            )
          })}
        </div>
      )}
    </div>
  )
}

============================================================
ARCHIVO: frontend\src\components\Navbar.tsx
LINEAS: 171
============================================================

'use client'

import Link from 'next/link'
import Image from 'next/image'
import { usePathname, useRouter } from 'next/navigation'
import { useEffect, useState } from 'react'
import { Gamepad2, Activity, LogOut, User, Library, Heart, Sparkles, Sun, Moon } from 'lucide-react'
import { getUserFromStorage, clearToken, type SteamUser } from '@/lib/auth'
import { steamLoginUrl } from '@/lib/api'

// ── Theme hook ────────────────────────────────────────────────────────────────

function useTheme() {
  const [theme, setTheme] = useState<'dark' | 'light'>('dark')

  useEffect(() => {
    // Leer preferencia guardada o usar dark por defecto
    const saved = localStorage.getItem('steamsense_theme') as 'dark' | 'light' | null
    const initial = saved ?? 'dark'
    setTheme(initial)
    document.documentElement.classList.toggle('light', initial === 'light')
  }, [])

  const toggle = () => {
    const next = theme === 'dark' ? 'light' : 'dark'
    setTheme(next)
    document.documentElement.classList.toggle('light', next === 'light')
    localStorage.setItem('steamsense_theme', next)
  }

  return { theme, toggle }
}

// ── Navbar ────────────────────────────────────────────────────────────────────

export default function Navbar() {
  const pathname = usePathname()
  const router   = useRouter()
  const { theme, toggle } = useTheme()
  const [user, setUser]     = useState<SteamUser | null>(null)
  const [menuOpen, setMenu] = useState(false)

  useEffect(() => {
    setUser(getUserFromStorage())
  }, [pathname])

  const logout = () => {
    clearToken()
    setUser(null)
    router.push('/')
  }

  const navLinks = [
    { href: '/',        label: 'Search'    },
    { href: '/explore', label: 'Explore'   },
    ...(user ? [{ href: '/dashboard', label: 'Dashboard' }] : []),
  ]

  return (
    <nav className="fixed top-0 left-0 right-0 z-40 glass border-b border-steam-border/50">
      <div className="max-w-6xl mx-auto px-6 h-14 flex items-center justify-between">

        {/* Logo */}
        <Link href="/" className="flex items-center gap-2.5 group flex-shrink-0">
          <div className="w-7 h-7 rounded-lg bg-steam-cyan/10 border border-steam-cyan/20 flex items-center justify-center group-hover:bg-steam-cyan/20 transition-colors">
            <Gamepad2 size={14} className="text-steam-cyan" />
          </div>
          <span className="font-display font-bold text-steam-text text-sm tracking-wide">
            Steam<span className="text-steam-cyan">Sense</span>
          </span>
        </Link>

        {/* Nav links */}
        <div className="flex items-center gap-1">
          {navLinks.map(({ href, label }) => {
            const active = href === '/' ? pathname === '/' : pathname.startsWith(href)
            return (
              <Link key={href} href={href}
                className={`px-3 py-1.5 rounded-lg text-xs font-mono transition-all ${
                  active
                    ? 'bg-steam-cyan/10 text-steam-cyan'
                    : 'text-steam-subtle hover:text-steam-text hover:bg-steam-muted'
                }`}>
                {label}
              </Link>
            )
          })}
        </div>

        {/* Right: status + theme toggle + auth */}
        <div className="flex items-center gap-3">

          {/* Live indicator */}
          <div className="hidden sm:flex items-center gap-1.5 text-steam-subtle text-xs font-mono">
            <Activity size={10} className="text-steam-green" />
            <span className="text-steam-green">Live</span>
          </div>

          {/* Theme toggle */}
          <button
            onClick={toggle}
            aria-label={theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'}
            className="w-8 h-8 flex items-center justify-center rounded-lg glass hover:border-steam-cyan/30 transition-all group"
          >
            {theme === 'dark' ? (
              <Sun size={14} className="text-steam-subtle group-hover:text-steam-amber transition-colors" />
            ) : (
              <Moon size={14} className="text-steam-subtle group-hover:text-steam-cyan transition-colors" />
            )}
          </button>

          {/* Auth */}
          {user ? (
            <div className="relative">
              <button
                onClick={() => setMenu(v => !v)}
                className="flex items-center gap-2 px-2 py-1.5 glass rounded-xl hover:border-steam-cyan/30 transition-all"
              >
                {user.avatar_url ? (
                  <Image src={user.avatar_url} alt={user.display_name} width={24} height={24}
                    className="rounded-full" unoptimized />
                ) : (
                  <div className="w-6 h-6 rounded-full bg-steam-muted flex items-center justify-center">
                    <User size={12} className="text-steam-subtle" />
                  </div>
                )}
                <span className="text-steam-text text-xs font-mono max-w-[100px] truncate hidden sm:block">
                  {user.display_name}
                </span>
              </button>

              {menuOpen && (
                <div className="absolute right-0 top-full mt-2 w-52 glass rounded-xl border border-steam-border overflow-hidden z-50">
                  <div className="px-4 py-3 border-b border-steam-border">
                    <p className="text-steam-text text-xs font-semibold">{user.display_name}</p>
                    <p className="text-steam-subtle text-xs font-mono mt-0.5">Steam ID: {user.steam_id.slice(-8)}</p>
                  </div>
                  {[
                    { href: '/dashboard',              icon: Library,  label: 'My Dashboard'    },
                    { href: '/dashboard?tab=wishlist', icon: Heart,    label: 'Wishlist'         },
                    { href: '/dashboard?tab=recs',     icon: Sparkles, label: 'Recommendations' },
                  ].map(({ href, icon: Icon, label }) => (
                    <Link key={href} href={href} onClick={() => setMenu(false)}
                      className="flex items-center gap-3 px-4 py-2.5 text-steam-subtle text-xs font-mono hover:text-steam-text hover:bg-steam-muted transition-colors">
                      <Icon size={13} /> {label}
                    </Link>
                  ))}
                  <button onClick={logout}
                    className="flex items-center gap-3 px-4 py-2.5 text-steam-red text-xs font-mono hover:bg-steam-red/10 transition-colors w-full border-t border-steam-border">
                    <LogOut size={13} /> Sign out
                  </button>
                </div>
              )}
            </div>
          ) : (
            <a href={steamLoginUrl}
              className="flex items-center gap-2 px-3 py-1.5 bg-steam-cyan/10 border border-steam-cyan/20 rounded-xl text-steam-cyan text-xs font-mono hover:bg-steam-cyan/20 transition-all">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M11.979 0C5.678 0 .511 4.86.022 11.037l6.432 2.658c.545-.371 1.203-.59 1.912-.59.063 0 .125.004.188.006l2.861-4.142V8.91c0-2.495 2.028-4.524 4.524-4.524 2.494 0 4.524 2.031 4.524 4.527s-2.03 4.525-4.524 4.525h-.105l-4.076 2.911c0 .052.004.105.004.159 0 1.875-1.515 3.396-3.39 3.396-1.635 0-3.016-1.173-3.331-2.727L.436 15.27C1.862 20.307 6.486 24 11.979 24c6.627 0 11.999-5.373 11.999-12S18.605 0 11.979 0z"/>
              </svg>
              Sign in with Steam
            </a>
          )}
        </div>
      </div>

      {/* Close menu on outside click */}
      {menuOpen && <div className="fixed inset-0 z-[-1]" onClick={() => setMenu(false)} />}
    </nav>
  )
}

============================================================
ARCHIVO: frontend\src\components\NextSalePredictor.tsx
LINEAS: 138
============================================================

'use client'

import { useMemo } from 'react'
import { Calendar, TrendingDown, AlertCircle } from 'lucide-react'
import type { PricePoint, SeasonalPattern } from '@/lib/types'
import { MONTH_NAMES } from '@/lib/utils'

interface Props {
  history: PricePoint[]
  seasonal: SeasonalPattern[]
}

const SALE_SEASONS = [
  { months: [11, 12], name: 'Winter Sale',        icon: '❄️' },
  { months: [6, 7],   name: 'Summer Sale',         icon: '☀️' },
  { months: [2],      name: 'Lunar New Year Sale', icon: '🧧' },
  { months: [10, 11], name: 'Autumn / Halloween',  icon: '🎃' },
  { months: [5, 6],   name: 'Spring Sale',         icon: '🌸' },
]

export default function NextSalePredictor({ history, seasonal }: Props) {
  const analysis = useMemo(() => {
    if (!history.length) return null

    const now       = new Date()
    const curMonth  = now.getMonth() + 1

    // Average gap between sale events in days
    const saleDates = history
      .filter(h => h.cut_pct > 0)
      .map(h => new Date(h.timestamp))
      .sort((a, b) => a.getTime() - b.getTime())

    if (saleDates.length < 2) return null

    const gaps: number[] = []
    for (let i = 1; i < saleDates.length; i++) {
      gaps.push((saleDates[i].getTime() - saleDates[i-1].getTime()) / 86400000)
    }
    const avgGap   = gaps.reduce((a, b) => a + b, 0) / gaps.length
    const lastSale = saleDates[saleDates.length - 1]
    const daysSinceLast = (now.getTime() - lastSale.getTime()) / 86400000
    const daysUntilNext = Math.max(0, Math.round(avgGap - daysSinceLast))

    // Which upcoming steam season has the best historical discount for this game?
    const seasonalMap = Object.fromEntries(seasonal.map(s => [s.month, s.avg_discount]))
    const upcomingSeasons = SALE_SEASONS
      .map(s => ({
        ...s,
        avgDiscount: Math.round(
          s.months.reduce((sum, m) => sum + (seasonalMap[m] || 0), 0) / s.months.length
        ),
        monthsUntil: Math.min(...s.months.map(m => {
          let diff = m - curMonth
          if (diff < 0) diff += 12
          return diff
        }))
      }))
      .filter(s => s.avgDiscount > 0)
      .sort((a, b) => b.avgDiscount - a.avgDiscount)

    const bestSeason = upcomingSeasons[0] || null

    return { avgGap: Math.round(avgGap), daysSinceLast: Math.round(daysSinceLast), daysUntilNext, bestSeason, saleDates, upcomingSeasons }
  }, [history, seasonal])

  if (!analysis) return null

  const { avgGap, daysSinceLast, daysUntilNext, bestSeason, upcomingSeasons } = analysis
  const urgency = daysUntilNext <= 7 ? 'high' : daysUntilNext <= 30 ? 'medium' : 'low'

  return (
    <div className="glass rounded-2xl p-5 space-y-4">
      <div className="flex items-center gap-2">
        <Calendar size={14} className="text-steam-cyan" />
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest">Sale Predictor</p>
      </div>

      {/* Next sale estimate */}
      <div className={`rounded-xl px-4 py-3 border ${
        urgency === 'high'   ? 'bg-steam-green/10 border-steam-green/30' :
        urgency === 'medium' ? 'bg-steam-amber/10 border-steam-amber/30' :
                               'bg-steam-muted border-steam-border'
      }`}>
        <p className="text-steam-subtle text-xs font-mono mb-1">Estimated next sale</p>
        <p className={`font-display font-bold text-lg ${
          urgency === 'high' ? 'text-steam-green' : urgency === 'medium' ? 'text-steam-amber' : 'text-steam-text'
        }`}>
          {daysUntilNext === 0 ? '🎯 Might be on sale now!' :
           daysUntilNext <= 7  ? `In ~${daysUntilNext} days` :
           daysUntilNext <= 30 ? `In ~${daysUntilNext} days` :
           `In ~${Math.round(daysUntilNext / 30)} months`}
        </p>
        <p className="text-steam-subtle text-xs font-mono mt-1">
          Last sale was {Math.round(daysSinceLast)}d ago · avg gap {avgGap}d
        </p>
      </div>

      {/* Seasonal breakdown */}
      {upcomingSeasons.length > 0 && (
        <div className="space-y-2">
          <p className="text-steam-subtle text-xs font-mono">Historically best seasons</p>
          {upcomingSeasons.slice(0, 3).map(s => (
            <div key={s.name} className="flex items-center gap-3">
              <span className="text-base w-6 text-center">{s.icon}</span>
              <div className="flex-1">
                <div className="flex justify-between text-xs mb-1">
                  <span className="text-steam-text">{s.name}</span>
                  <span className="text-steam-green font-mono">avg −{s.avgDiscount}%</span>
                </div>
                <div className="h-1 bg-steam-muted rounded-full">
                  <div
                    className="h-full bg-gradient-to-r from-steam-cyan to-steam-green rounded-full"
                    style={{ width: `${Math.min(100, s.avgDiscount * 2)}%` }}
                  />
                </div>
              </div>
              <span className="text-steam-subtle text-xs font-mono w-14 text-right">
                {s.monthsUntil === 0 ? 'now' : `${s.monthsUntil}mo`}
              </span>
            </div>
          ))}
        </div>
      )}

      {bestSeason && (
        <div className="flex items-start gap-2 text-xs text-steam-subtle font-mono border-t border-steam-border/50 pt-3">
          <AlertCircle size={11} className="text-steam-amber mt-0.5 flex-shrink-0" />
          <span>
            Best historical discount during <span className="text-steam-amber">{bestSeason.name}</span> —
            avg {bestSeason.avgDiscount}% off.
            {bestSeason.monthsUntil === 0 ? ' That\'s right now!' : ` ${bestSeason.monthsUntil} month(s) away.`}
          </span>
        </div>
      )}
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\PredictionBadge.tsx
LINEAS: 127
============================================================

'use client'

import { TrendingDown, Clock, Zap, Shield } from 'lucide-react'
import type { PredictionResponse } from '@/lib/types'
import { formatPrice } from '@/lib/utils'

interface Props {
  data: PredictionResponse
  loading?: boolean
}

export default function PredictionBadge({ data, loading }: Props) {
  const { prediction, price_context } = data
  const isBuy = prediction.signal === 'BUY'
  const score = prediction.score

  const scoreColor =
    score >= 70 ? 'text-steam-green' :
    score >= 45 ? 'text-steam-amber' :
    'text-steam-red'

  const ringColor =
    score >= 70 ? 'border-steam-green/40 glow-green' :
    score >= 45 ? 'border-steam-amber/40 glow-amber' :
    'border-steam-red/40'

  const fillDeg = Math.round((score / 100) * 360)

  return (
    <div className="glass rounded-2xl p-6 space-y-6">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest mb-1">ML Prediction</p>
          <h2 className="text-steam-text text-lg font-display font-semibold">Should you buy?</h2>
        </div>
        {data.from_cache && (
          <span className="text-steam-subtle text-xs font-mono bg-steam-muted px-2 py-1 rounded">
            cached
          </span>
        )}
      </div>

      {/* Score ring + signal */}
      <div className="flex items-center gap-6">
        {/* Circular score */}
        <div className="relative flex-shrink-0">
          <svg width="88" height="88" viewBox="0 0 88 88" className="rotate-[-90deg]">
            <circle cx="44" cy="44" r="36" fill="none" stroke="#1f2d45" strokeWidth="6" />
            <circle
              cx="44" cy="44" r="36"
              fill="none"
              stroke={isBuy ? '#00ff87' : score >= 45 ? '#ffb800' : '#ff4757'}
              strokeWidth="6"
              strokeLinecap="round"
              strokeDasharray={`${2 * Math.PI * 36}`}
              strokeDashoffset={`${2 * Math.PI * 36 * (1 - score / 100)}`}
              style={{ transition: 'stroke-dashoffset 1s ease' }}
            />
          </svg>
          <div className="absolute inset-0 flex flex-col items-center justify-center">
            <span className={`text-xl font-display font-bold ${scoreColor}`}>{Math.round(score)}</span>
            <span className="text-steam-subtle text-xs">/ 100</span>
          </div>
        </div>

        {/* Signal */}
        <div className="flex-1">
          <div className={`
            inline-flex items-center gap-2 px-4 py-2 rounded-xl font-display font-bold text-2xl mb-2
            ${isBuy
              ? 'bg-steam-green/10 text-steam-green border border-steam-green/30'
              : 'bg-steam-amber/10 text-steam-amber border border-steam-amber/30'
            }
          `}>
            {isBuy ? <Zap size={20} /> : <Clock size={20} />}
            {prediction.signal}
          </div>
          <p className="text-steam-text text-sm leading-relaxed">
            {prediction.reason}
          </p>
        </div>
      </div>

      {/* Confidence */}
      {prediction.confidence > 0 && (
        <div className="space-y-1">
          <div className="flex justify-between text-xs text-steam-subtle font-mono">
            <span className="flex items-center gap-1"><Shield size={10} /> Confidence</span>
            <span>{Math.round(prediction.confidence * 100)}%</span>
          </div>
          <div className="h-1.5 bg-steam-muted rounded-full overflow-hidden">
            <div
              className="h-full bg-gradient-to-r from-steam-cyan to-steam-green rounded-full transition-all duration-1000"
              style={{ width: `${prediction.confidence * 100}%` }}
            />
          </div>
        </div>
      )}

      {/* Price context */}
      <div className="grid grid-cols-3 gap-3 pt-2 border-t border-steam-border">
        {[
          { label: 'Current', value: formatPrice(price_context.current_price), highlight: price_context.current_discount_pct > 0 },
          { label: 'All-time low', value: formatPrice(price_context.min_price_ever) },
          { label: 'Avg price', value: formatPrice(price_context.avg_price) },
        ].map(({ label, value, highlight }) => (
          <div key={label} className="text-center">
            <div className={`text-base font-mono font-semibold ${highlight ? 'text-steam-green' : 'text-steam-text'}`}>
              {value}
            </div>
            <div className="text-steam-subtle text-xs mt-0.5">{label}</div>
          </div>
        ))}
      </div>

      {price_context.current_discount_pct > 0 && (
        <div className="flex items-center gap-2 px-3 py-2 bg-steam-green/10 border border-steam-green/20 rounded-lg">
          <TrendingDown size={14} className="text-steam-green" />
          <span className="text-steam-green text-sm font-semibold">
            {price_context.current_discount_pct}% OFF right now
          </span>
        </div>
      )}
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\PriceAlertBanner.tsx
LINEAS: 63
============================================================

import { AlertTriangle, TrendingDown, Flame } from 'lucide-react'
import { formatPrice } from '@/lib/utils'

interface Props {
  currentPrice: number
  minPrice: number
  discountPct: number
  avgPrice: number
}

export default function PriceAlertBanner({ currentPrice, minPrice, discountPct, avgPrice }: Props) {
  const isAtLow = currentPrice <= minPrice * 1.02
  const isNearLow = !isAtLow && currentPrice <= minPrice * 1.1
  const isBigDeal = discountPct >= 75
  const isBelowAvg = currentPrice < avgPrice * 0.7

  if (!isAtLow && !isNearLow && !isBigDeal && !isBelowAvg) return null

  if (isAtLow) return (
    <div className="rounded-xl px-5 py-3.5 border border-steam-green/40 bg-steam-green/10 animate-pulse-glow">
      <div className="flex items-center gap-3">
        <div className="w-8 h-8 rounded-lg bg-steam-green/20 flex items-center justify-center flex-shrink-0">
          <TrendingDown size={16} className="text-steam-green" />
        </div>
        <div>
          <p className="text-steam-green font-semibold text-sm">All-Time Low Price!</p>
          <p className="text-steam-green/70 text-xs font-mono">
            {formatPrice(currentPrice)} — the lowest this game has ever been
          </p>
        </div>
      </div>
    </div>
  )

  if (isBigDeal) return (
    <div className="rounded-xl px-5 py-3.5 border border-steam-amber/40 bg-steam-amber/10">
      <div className="flex items-center gap-3">
        <div className="w-8 h-8 rounded-lg bg-steam-amber/20 flex items-center justify-center flex-shrink-0">
          <Flame size={16} className="text-steam-amber" />
        </div>
        <div>
          <p className="text-steam-amber font-semibold text-sm">Massive {discountPct}% Discount</p>
          <p className="text-steam-amber/70 text-xs font-mono">
            All-time low was {formatPrice(minPrice)} · You're saving {formatPrice((avgPrice || 0) - currentPrice)}
          </p>
        </div>
      </div>
    </div>
  )

  if (isNearLow) return (
    <div className="rounded-xl px-5 py-3.5 border border-steam-cyan/30 bg-steam-cyan/5">
      <div className="flex items-center gap-3">
        <AlertTriangle size={16} className="text-steam-cyan flex-shrink-0" />
        <p className="text-steam-cyan text-sm">
          Near all-time low — just {formatPrice(currentPrice - minPrice)} above the record
        </p>
      </div>
    </div>
  )

  return null
}


============================================================
ARCHIVO: frontend\src\components\PriceAlertButton.tsx
LINEAS: 175
============================================================

'use client'

import { useState, useEffect, useCallback } from 'react'
import { Bell, BellOff, BellRing, Check } from 'lucide-react'

// ── Tipos ─────────────────────────────────────────────────────────────────────

interface WishlistGame {
  appid: number
  game_title: string
  current_price: number
  discount_pct: number
  all_time_low: number
  signal?: string
}

// ── Storage helpers ───────────────────────────────────────────────────────────

const STORAGE_KEY = 'steamsense_notified'

function getNotified(): Record<string, number> {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') }
  catch { return {} }
}

function markNotified(appid: number) {
  const n = getNotified()
  n[appid] = Date.now()
  localStorage.setItem(STORAGE_KEY, JSON.stringify(n))
}

function wasRecentlyNotified(appid: number, cooldownHours = 24): boolean {
  const n = getNotified()
  if (!n[appid]) return false
  return Date.now() - n[appid] < cooldownHours * 60 * 60 * 1000
}

// ── Notificación del navegador ────────────────────────────────────────────────

function sendNotification(title: string, body: string, icon?: string) {
  if (typeof window === 'undefined' || !('Notification' in window)) return
  if (Notification.permission !== 'granted') return
  try {
    new Notification(title, {
      body,
      icon: icon || '/favicon.ico',
      badge: '/favicon.ico',
      tag: `steamsense-${title}`, // evita duplicados
    })
  } catch (e) {
    console.warn('Notification error:', e)
  }
}

// ── Hook principal ────────────────────────────────────────────────────────────

export function usePriceAlerts(wishlist: WishlistGame[]) {
  const [permission, setPermission] = useState<NotificationPermission>('default')
  const [alertCount, setAlertCount] = useState(0)

  // Leer permiso actual al montar
  useEffect(() => {
    if (typeof window !== 'undefined' && 'Notification' in window) {
      setPermission(Notification.permission)
    }
  }, [])

  // Revisar wishlist cada vez que cambia y disparar notificaciones
  useEffect(() => {
    if (permission !== 'granted' || !wishlist.length) return

    let triggered = 0
    for (const g of wishlist) {
      if (wasRecentlyNotified(g.appid)) continue

      const isAtLow   = g.all_time_low > 0 && g.current_price > 0
                        && g.current_price <= g.all_time_low * 1.05
      const isBigSale = g.discount_pct >= 50
      const isBuy     = g.signal === 'BUY'

      if (isAtLow) {
        sendNotification(
          `🔥 ${g.game_title} — All-Time Low!`,
          `${g.game_title} is at its lowest price ever: $${g.current_price.toFixed(2)}`,
        )
        markNotified(g.appid)
        triggered++
      } else if (isBuy && isBigSale) {
        sendNotification(
          `⚡ BUY Signal: ${g.game_title}`,
          `${g.discount_pct}% off — ML model says this is the right time to buy.`,
        )
        markNotified(g.appid)
        triggered++
      } else if (isBigSale) {
        sendNotification(
          `💰 ${g.game_title} — ${g.discount_pct}% off`,
          `Your wishlist game is on sale for $${g.current_price.toFixed(2)}`,
        )
        markNotified(g.appid)
        triggered++
      }
    }

    if (triggered > 0) setAlertCount(triggered)
  }, [wishlist, permission])

  const requestPermission = useCallback(async () => {
    if (typeof window === 'undefined' || !('Notification' in window)) return
    const result = await Notification.requestPermission()
    setPermission(result)
    return result
  }, [])

  return { permission, requestPermission, alertCount }
}

// ── Componente botón ──────────────────────────────────────────────────────────

interface Props {
  wishlist: WishlistGame[]
}

export default function PriceAlertButton({ wishlist }: Props) {
  const { permission, requestPermission, alertCount } = usePriceAlerts(wishlist)
  const [clicked, setClicked] = useState(false)
  const [loading, setLoading] = useState(false)

  const handleClick = async () => {
    if (permission === 'granted') return // ya activado, no hacer nada
    setLoading(true)
    const result = await requestPermission()
    setLoading(false)
    if (result === 'granted') setClicked(true)
  }

  // Notificaciones no soportadas
  if (typeof window !== 'undefined' && !('Notification' in window)) return null

  if (permission === 'denied') return (
    <div className="flex items-center gap-2 px-4 py-2 glass rounded-xl text-steam-subtle text-xs font-mono opacity-60 cursor-not-allowed">
      <BellOff size={13} />
      Notifications blocked — enable in browser settings
    </div>
  )

  if (permission === 'granted') return (
    <div className="flex items-center gap-2 px-4 py-2 glass rounded-xl text-steam-green text-xs font-mono border border-steam-green/20">
      <BellRing size={13} />
      Price alerts active
      {alertCount > 0 && (
        <span className="bg-steam-green/20 text-steam-green px-1.5 py-0.5 rounded-full text-xs">
          {alertCount} sent
        </span>
      )}
    </div>
  )

  return (
    <button
      onClick={handleClick}
      disabled={loading}
      className="flex items-center gap-2 px-4 py-2 glass rounded-xl text-sm font-mono text-steam-subtle hover:text-steam-amber hover:border-steam-amber/30 transition-all disabled:opacity-50"
    >
      {loading ? (
        <span className="w-3.5 h-3.5 border border-steam-subtle border-t-steam-amber rounded-full animate-spin" />
      ) : clicked ? (
        <Check size={13} className="text-steam-green" />
      ) : (
        <Bell size={13} />
      )}
      {clicked ? 'Alerts enabled!' : 'Enable price alerts'}
    </button>
  )
}

============================================================
ARCHIVO: frontend\src\components\PriceChart.tsx
LINEAS: 215
============================================================

'use client'

import { useState, useMemo } from 'react'
import {
  AreaChart, Area, XAxis, YAxis, CartesianGrid,
  Tooltip, ResponsiveContainer, ReferenceLine, Brush
} from 'recharts'
import type { PricePoint, PriceStats } from '@/lib/types'
import { formatDate, formatPrice } from '@/lib/utils'

interface Props {
  history: PricePoint[]
  stats?: PriceStats
}

const RANGES = [
  { label: '1M',  days: 30  },
  { label: '3M',  days: 90  },
  { label: '6M',  days: 180 },
  { label: '1Y',  days: 365 },
  { label: 'ALL', days: 0   },
]

const CustomTooltip = ({ active, payload, label }: any) => {
  if (!active || !payload?.length) return null
  const d = payload[0].payload as PricePoint
  return (
    <div className="glass rounded-xl px-4 py-3 text-sm space-y-1.5 min-w-[180px] border border-steam-cyan/20">
      <p className="text-steam-subtle text-xs font-mono">{formatDate(label)}</p>
      <div className="flex items-baseline gap-2">
        <p className="text-steam-cyan font-mono font-bold text-base">{formatPrice(d.price_usd)}</p>
        {d.regular_usd > 0 && d.regular_usd !== d.price_usd && (
          <p className="text-steam-subtle text-xs font-mono line-through">{formatPrice(d.regular_usd)}</p>
        )}
      </div>
      {d.cut_pct > 0 && (
        <div className="inline-block bg-steam-green/15 text-steam-green text-xs font-mono px-2 py-0.5 rounded">
          −{d.cut_pct}% off
        </div>
      )}
      <p className="text-steam-subtle text-xs">{d.shop_name}</p>
    </div>
  )
}

export default function PriceChart({ history, stats }: Props) {
  const [activeRange, setActiveRange] = useState('ALL')
  const [showDiscounts, setShowDiscounts] = useState(true)

  const filtered = useMemo(() => {
    const range = RANGES.find(r => r.label === activeRange)
    if (!range || range.days === 0) return history
    const cutoff = new Date()
    cutoff.setDate(cutoff.getDate() - range.days)
    return history.filter(p => new Date(p.timestamp) >= cutoff)
  }, [history, activeRange])

  // Downsample for perf if too many points
  const data = useMemo(() => {
    if (filtered.length <= 300) return filtered
    const step = Math.ceil(filtered.length / 300)
    return filtered.filter((_, i) => i % step === 0)
  }, [filtered])

  const minPrice = stats?.min_price ?? Math.min(...data.map(d => d.price_usd))
  const maxPrice = stats?.max_price ?? Math.max(...data.map(d => d.price_usd))

  // Compute discount periods for highlighting
  const discountDots = useMemo(() =>
    data.filter(d => d.cut_pct > 0).map(d => d.timestamp),
    [data]
  )

  if (!history.length) return (
    <div className="glass rounded-2xl p-8 text-center text-steam-subtle">
      No price history available.
    </div>
  )

  return (
    <div className="glass rounded-2xl p-6 space-y-4">
      {/* Header row */}
      <div className="flex items-center justify-between flex-wrap gap-3">
        <div>
          <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest mb-1">Price History</p>
          <div className="flex items-center gap-4 text-sm flex-wrap">
            <span className="text-steam-subtle text-xs">
              ATL <span className="text-steam-green font-mono font-semibold">{formatPrice(minPrice)}</span>
            </span>
            <span className="text-steam-subtle text-xs">
              Peak <span className="text-steam-text font-mono">{formatPrice(maxPrice)}</span>
            </span>
            <span className="text-steam-subtle/60 text-xs font-mono">{data.length} pts</span>
          </div>
        </div>

        {/* Range selector */}
        <div className="flex items-center gap-1">
          <button
            onClick={() => setShowDiscounts(v => !v)}
            className={`px-2.5 py-1 rounded-lg text-xs font-mono transition-all mr-2 ${
              showDiscounts
                ? 'bg-steam-green/15 text-steam-green border border-steam-green/30'
                : 'text-steam-subtle hover:text-steam-text glass'
            }`}
          >
            Sales
          </button>
          {RANGES.map(r => (
            <button
              key={r.label}
              onClick={() => setActiveRange(r.label)}
              className={`px-2.5 py-1 rounded-lg text-xs font-mono transition-all ${
                activeRange === r.label
                  ? 'bg-steam-cyan/15 text-steam-cyan border border-steam-cyan/30'
                  : 'text-steam-subtle hover:text-steam-text glass'
              }`}
            >
              {r.label}
            </button>
          ))}
        </div>
      </div>

      {/* Chart */}
      <ResponsiveContainer width="100%" height={260}>
        <AreaChart data={data} margin={{ top: 8, right: 8, bottom: 0, left: 8 }}>
          <defs>
            <linearGradient id="priceGrad" x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%"  stopColor="#00d4ff" stopOpacity={0.25} />
              <stop offset="95%" stopColor="#00d4ff" stopOpacity={0.02} />
            </linearGradient>
            <linearGradient id="discountGrad" x1="0" y1="0" x2="0" y2="1">
              <stop offset="5%"  stopColor="#00ff87" stopOpacity={0.3} />
              <stop offset="95%" stopColor="#00ff87" stopOpacity={0.02} />
            </linearGradient>
          </defs>
          <CartesianGrid strokeDasharray="3 3" stroke="#1f2d45" vertical={false} />
          <XAxis
            dataKey="timestamp"
            tickFormatter={v => {
              const d = new Date(v)
              return `${d.toLocaleString('default', { month: 'short' })} '${String(d.getFullYear()).slice(2)}`
            }}
            tick={{ fill: '#5c7a9e', fontSize: 10, fontFamily: 'DM Mono, monospace' }}
            tickLine={false} axisLine={{ stroke: '#1f2d45' }}
            interval="preserveStartEnd" minTickGap={60}
          />
          <YAxis
            tickFormatter={v => `$${v}`}
            tick={{ fill: '#5c7a9e', fontSize: 10, fontFamily: 'DM Mono, monospace' }}
            tickLine={false} axisLine={false} width={42}
            domain={['auto', 'auto']}
          />
          <Tooltip content={<CustomTooltip />} />
          {minPrice > 0 && (
            <ReferenceLine
              y={minPrice}
              stroke="#00ff87" strokeDasharray="5 3" strokeOpacity={0.5}
              label={{ value: 'ATL', position: 'insideTopRight', fill: '#00ff87', fontSize: 9, fontFamily: 'DM Mono, monospace' }}
            />
          )}
          {/* Discount periods overlay */}
          {showDiscounts && (
            <Area
              type="stepAfter"
              dataKey={(d: PricePoint) => d.cut_pct > 0 ? d.price_usd : null}
              stroke="#00ff87"
              strokeWidth={2}
              fill="url(#discountGrad)"
              dot={false}
              connectNulls={false}
              activeDot={{ r: 5, fill: '#00ff87', strokeWidth: 0 }}
            />
          )}
          <Area
            type="monotone"
            dataKey="price_usd"
            stroke="#00d4ff"
            strokeWidth={1.5}
            fill="url(#priceGrad)"
            dot={false}
            activeDot={{ r: 4, fill: '#00d4ff', strokeWidth: 0 }}
          />
        </AreaChart>
      </ResponsiveContainer>

      {/* Stats row */}
      {data.length > 0 && (() => {
        const salePts = data.filter(d => d.cut_pct > 0)
        const avgDisc = salePts.length
          ? Math.round(salePts.reduce((s, d) => s + d.cut_pct, 0) / salePts.length)
          : 0
        const maxDisc = salePts.length ? Math.max(...salePts.map(d => d.cut_pct)) : 0
        return (
          <div className="flex gap-4 pt-2 border-t border-steam-border flex-wrap text-xs font-mono">
            <span className="text-steam-subtle">
              Sale events: <span className="text-steam-text">{salePts.length}</span>
            </span>
            {avgDisc > 0 && (
              <span className="text-steam-subtle">
                Avg discount: <span className="text-steam-amber">{avgDisc}%</span>
              </span>
            )}
            {maxDisc > 0 && (
              <span className="text-steam-subtle">
                Best discount: <span className="text-steam-green">{maxDisc}%</span>
              </span>
            )}
          </div>
        )
      })()}
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\PriceHistogram.tsx
LINEAS: 122
============================================================

'use client'

import { useMemo } from 'react'
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, Cell, ReferenceLine } from 'recharts'
import type { PricePoint } from '@/lib/types'
import { formatPrice } from '@/lib/utils'

interface Props {
  history: PricePoint[]
  minPrice?: number
  avgPrice?: number
}

const CustomTooltip = ({ active, payload }: any) => {
  if (!active || !payload?.length) return null
  const d = payload[0].payload
  return (
    <div className="glass rounded-xl px-3 py-2 text-xs font-mono border border-steam-cyan/20">
      <p className="text-steam-subtle">{d.label}</p>
      <p className="text-steam-cyan font-bold">{d.count} records</p>
      <p className="text-steam-subtle">{d.pct}% of history</p>
    </div>
  )
}

export default function PriceHistogram({ history, minPrice, avgPrice }: Props) {
  const bins = useMemo(() => {
    if (!history.length) return []

    const prices = history.map(h => h.price_usd).filter(p => p >= 0)
    if (!prices.length) return []

    const max = Math.max(...prices)
    const min = Math.min(...prices)
    if (max === min) return []

    // Create 10 bins
    const BIN_COUNT = 10
    const binSize = (max - min) / BIN_COUNT
    const buckets = Array.from({ length: BIN_COUNT }, (_, i) => ({
      start: min + i * binSize,
      end:   min + (i + 1) * binSize,
      count: 0,
    }))

    prices.forEach(p => {
      const idx = Math.min(Math.floor((p - min) / binSize), BIN_COUNT - 1)
      buckets[idx].count++
    })

    return buckets.map(b => ({
      label: `${formatPrice(b.start)}–${formatPrice(b.end)}`,
      midpoint: (b.start + b.end) / 2,
      count: b.count,
      pct: Math.round(b.count / prices.length * 100),
      start: b.start,
      end: b.end,
    }))
  }, [history])

  if (!bins.length) return null

  const maxCount = Math.max(...bins.map(b => b.count))

  return (
    <div className="glass rounded-2xl p-5 space-y-3">
      <div className="flex items-center justify-between">
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest">
          Price Distribution
        </p>
        <p className="text-steam-subtle/60 text-xs font-mono">
          {history.length} records
        </p>
      </div>

      <ResponsiveContainer width="100%" height={140}>
        <BarChart data={bins} margin={{ top: 4, right: 4, bottom: 4, left: 4 }} barCategoryGap="10%">
          <XAxis
            dataKey="label"
            tick={false}
            axisLine={{ stroke: '#1f2d45' }}
            tickLine={false}
          />
          <YAxis hide />
          <Tooltip content={<CustomTooltip />} cursor={{ fill: 'rgba(0,212,255,0.05)' }} />

          {/* ATL reference */}
          {minPrice != null && minPrice > 0 && (
            <ReferenceLine
              x={bins.find(b => b.start <= minPrice && minPrice <= b.end)?.label}
              stroke="#00ff87" strokeDasharray="3 3" strokeOpacity={0.7}
              label={{ value: 'ATL', position: 'insideTopLeft', fill: '#00ff87', fontSize: 9, fontFamily: 'DM Mono, monospace' }}
            />
          )}

          <Bar dataKey="count" radius={[3, 3, 0, 0]}>
            {bins.map((b, i) => {
              // Color: green if at/near ATL, cyan otherwise, with intensity by frequency
              const isLow   = minPrice != null && b.end <= (minPrice * 1.2)
              const opacity = 0.3 + (b.count / maxCount) * 0.7
              return (
                <Cell
                  key={i}
                  fill={isLow ? `rgba(0,255,135,${opacity})` : `rgba(0,212,255,${opacity})`}
                />
              )
            })}
          </Bar>
        </BarChart>
      </ResponsiveContainer>

      {/* Price range labels */}
      <div className="flex justify-between text-xs font-mono text-steam-subtle/50">
        <span>{formatPrice(bins[0].start)}</span>
        {avgPrice && avgPrice > 0 && (
          <span className="text-steam-amber/70">avg {formatPrice(avgPrice)}</span>
        )}
        <span>{formatPrice(bins[bins.length - 1].end)}</span>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\PriceHistoryTable.tsx
LINEAS: 147
============================================================

'use client'

import { useState, useMemo } from 'react'
import { ChevronUp, ChevronDown, Search, Filter } from 'lucide-react'
import type { PricePoint } from '@/lib/types'
import { formatDate, formatPrice } from '@/lib/utils'

interface Props { history: PricePoint[] }

type SortKey = 'timestamp' | 'price_usd' | 'cut_pct'
type SortDir = 'asc' | 'desc'

export default function PriceHistoryTable({ history }: Props) {
  const [search, setSearch]   = useState('')
  const [onlySales, setOnlySales] = useState(false)
  const [sortKey, setSortKey] = useState<SortKey>('timestamp')
  const [sortDir, setSortDir] = useState<SortDir>('desc')
  const [page, setPage]       = useState(0)
  const PER_PAGE = 20

  const sorted = useMemo(() => {
    let rows = [...history]
    if (onlySales) rows = rows.filter(r => r.cut_pct > 0)
    if (search)    rows = rows.filter(r => r.shop_name.toLowerCase().includes(search.toLowerCase()))
    rows.sort((a, b) => {
      let va = a[sortKey], vb = b[sortKey]
      if (typeof va === 'string') va = new Date(va).getTime(), vb = new Date(vb as string).getTime()
      return sortDir === 'asc' ? (va as number) - (vb as number) : (vb as number) - (va as number)
    })
    return rows
  }, [history, search, onlySales, sortKey, sortDir])

  const pages  = Math.ceil(sorted.length / PER_PAGE)
  const slice  = sorted.slice(page * PER_PAGE, (page + 1) * PER_PAGE)

  const toggleSort = (key: SortKey) => {
    if (sortKey === key) setSortDir(d => d === 'asc' ? 'desc' : 'asc')
    else { setSortKey(key); setSortDir('desc') }
    setPage(0)
  }

  const SortIcon = ({ k }: { k: SortKey }) =>
    sortKey === k
      ? (sortDir === 'asc' ? <ChevronUp size={12} className="text-steam-cyan" /> : <ChevronDown size={12} className="text-steam-cyan" />)
      : <ChevronDown size={12} className="opacity-30" />

  return (
    <div className="glass rounded-2xl overflow-hidden">
      {/* Toolbar */}
      <div className="flex items-center gap-3 px-5 py-3.5 border-b border-steam-border flex-wrap">
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest flex-1">
          Price Records <span className="text-steam-text ml-1">{sorted.length}</span>
        </p>
        <div className="relative">
          <Search size={12} className="absolute left-2.5 top-1/2 -translate-y-1/2 text-steam-subtle" />
          <input
            value={search} onChange={e => { setSearch(e.target.value); setPage(0) }}
            placeholder="Filter store..."
            className="bg-steam-muted border border-steam-border rounded-lg pl-7 pr-3 py-1.5 text-xs font-mono text-steam-text placeholder:text-steam-subtle/50 focus:outline-none focus:border-steam-cyan/40 w-36"
          />
        </div>
        <button
          onClick={() => { setOnlySales(v => !v); setPage(0) }}
          className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-mono transition-all ${
            onlySales
              ? 'bg-steam-green/15 text-steam-green border border-steam-green/30'
              : 'glass text-steam-subtle hover:text-steam-text'
          }`}
        >
          <Filter size={10} /> Sales only
        </button>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <table className="w-full text-xs font-mono">
          <thead>
            <tr className="border-b border-steam-border/50">
              {([['timestamp','Date'],['price_usd','Price'],['','Regular'],['cut_pct','Discount'],['','Store']] as const).map(([key, label]) => (
                <th
                  key={label}
                  onClick={() => key ? toggleSort(key as SortKey) : null}
                  className={`text-left px-4 py-2.5 text-steam-subtle font-normal select-none ${key ? 'cursor-pointer hover:text-steam-text' : ''}`}
                >
                  <span className="flex items-center gap-1">
                    {label}
                    {key && <SortIcon k={key as SortKey} />}
                  </span>
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {slice.map((row, i) => {
              const hasSale = row.cut_pct > 0
              return (
                <tr
                  key={i}
                  className={`border-b border-steam-border/30 transition-colors hover:bg-steam-muted/30 ${
                    hasSale ? 'bg-steam-green/[0.03]' : ''
                  }`}
                >
                  <td className="px-4 py-2 text-steam-subtle">{formatDate(row.timestamp)}</td>
                  <td className={`px-4 py-2 font-semibold ${hasSale ? 'text-steam-green' : 'text-steam-text'}`}>
                    {formatPrice(row.price_usd)}
                  </td>
                  <td className="px-4 py-2 text-steam-subtle/60 line-through">
                    {row.regular_usd !== row.price_usd ? formatPrice(row.regular_usd) : ''}
                  </td>
                  <td className="px-4 py-2">
                    {hasSale
                      ? <span className="bg-steam-green/15 text-steam-green px-2 py-0.5 rounded text-xs">−{row.cut_pct}%</span>
                      : <span className="text-steam-subtle/40">—</span>
                    }
                  </td>
                  <td className="px-4 py-2 text-steam-subtle">{row.shop_name}</td>
                </tr>
              )
            })}
            {!slice.length && (
              <tr><td colSpan={5} className="px-4 py-8 text-center text-steam-subtle">No records match</td></tr>
            )}
          </tbody>
        </table>
      </div>

      {/* Pagination */}
      {pages > 1 && (
        <div className="flex items-center justify-between px-5 py-3 border-t border-steam-border/50">
          <span className="text-steam-subtle text-xs font-mono">
            Page {page + 1} of {pages}
          </span>
          <div className="flex gap-1">
            <button onClick={() => setPage(p => Math.max(0, p - 1))} disabled={page === 0}
              className="px-3 py-1 rounded glass text-steam-subtle text-xs disabled:opacity-30 hover:text-steam-text transition-colors">
              ←
            </button>
            <button onClick={() => setPage(p => Math.min(pages - 1, p + 1))} disabled={page === pages - 1}
              className="px-3 py-1 rounded glass text-steam-subtle text-xs disabled:opacity-30 hover:text-steam-text transition-colors">
              →
            </button>
          </div>
        </div>
      )}
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\ProfileInsights.tsx
LINEAS: 230
============================================================

'use client'

import { useMemo } from 'react'
import Link from 'next/link'
import { Trophy, TrendingDown, Gamepad2, DollarSign } from 'lucide-react'
import { steamImageUrl, formatPrice } from '@/lib/utils'

// ── Clasificador de géneros por nombre de juego ───────────────────────────────
// Heurística simple: detecta géneros a partir de palabras clave en el título.
// Es una aproximación suficiente sin necesitar la Steam API de géneros.
const GENRE_KEYWORDS: Record<string, string[]> = {
  'RPG':         ['rpg', 'role', 'quest', 'legend', 'fantasy', 'dragon', 'souls', 'elden', 'witcher', 'baldur', 'divinity'],
  'FPS':         ['shooter', 'warfare', 'combat', 'battlefield', 'counter', 'doom', 'halo', 'overwatch', 'valorant', 'cs2', 'csgo'],
  'Strategy':    ['civilization', 'civ', 'total war', 'crusader', 'europa', 'stellaris', 'xcom', 'command', 'age of'],
  'Action':      ['batman', 'spider', 'assassin', 'devil may', 'sekiro', 'dark souls', 'bloodborne', 'god of war', 'hack'],
  'Survival':    ['survival', 'minecraft', 'terraria', 'rust', 'ark', 'valheim', 'forest', 'stranded', 'subnautica'],
  'Racing':      ['racing', 'forza', 'gran turismo', 'need for speed', 'f1', 'mario kart', 'rocket league'],
  'Simulation':  ['simulator', 'cities', 'farming', 'stardew', 'sims', 'flight', 'euro truck', 'planet'],
  'Horror':      ['horror', 'resident evil', 'silent hill', 'outlast', 'amnesia', 'dead space', 'visage'],
  'Sports':      ['fifa', 'nba', 'nhl', 'nfl', 'pes', 'football', 'basketball', 'tennis', 'golf'],
  'Indie':       ['hollow knight', 'celeste', 'hades', 'dead cells', 'ori', 'cuphead', 'shovel knight'],
  'Adventure':   ['adventure', 'journey', 'telltale', 'life is strange', 'walking dead', 'monkey island'],
  'MOBA/Online': ['dota', 'league of legends', 'smite', 'heroes of the storm', 'paladins'],
}

function detectGenre(title: string): string {
  const lower = title.toLowerCase()
  for (const [genre, keywords] of Object.entries(GENRE_KEYWORDS)) {
    if (keywords.some(k => lower.includes(k))) return genre
  }
  return 'Other'
}

// ── Helpers ───────────────────────────────────────────────────────────────────

interface LibraryGame {
  appid: number
  game_title: string
  playtime_mins: number
  last_played?: string
  game_id?: string
  min_price?: number
  avg_price?: number
  max_discount?: number
  total_records?: number
}

interface Props {
  games: LibraryGame[]
}

export default function ProfileInsights({ games }: Props) {
  const insights = useMemo(() => {
    if (!games.length) return null

    // ── Top 3 juegos por horas jugadas ────────────────────────────────────────
    const top3 = [...games]
      .filter(g => g.playtime_mins > 0)
      .sort((a, b) => b.playtime_mins - a.playtime_mins)
      .slice(0, 3)

    // ── Géneros favoritos por horas jugadas ───────────────────────────────────
    const genreHours: Record<string, number> = {}
    for (const g of games) {
      if (g.playtime_mins <= 0) continue
      const genre = detectGenre(g.game_title)
      genreHours[genre] = (genreHours[genre] || 0) + g.playtime_mins
    }
    const totalPlaytime = Object.values(genreHours).reduce((a, b) => a + b, 0)
    const topGenres = Object.entries(genreHours)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([genre, mins]) => ({
        genre,
        hours: Math.round(mins / 60),
        pct:   totalPlaytime > 0 ? Math.round((mins / totalPlaytime) * 100) : 0,
      }))

    // ── Precio ahorrado estimado ───────────────────────────────────────────────
    // Para cada juego trackeado: (avg_price - min_price) * probabilidad de haberlo comprado en sale
    // Es una estimación — no sabemos el precio de compra real.
    let savedEstimate = 0
    let gamesOnSale   = 0
    for (const g of games) {
      if (g.avg_price && g.min_price && g.avg_price > g.min_price && g.max_discount && g.max_discount > 0) {
        savedEstimate += (g.avg_price - g.min_price)
        gamesOnSale++
      }
    }

    return { top3, topGenres, savedEstimate, gamesOnSale, totalHours: Math.round(totalPlaytime / 60) }
  }, [games])

  if (!insights || !games.length) return null

  const genreColors = [
    'bg-steam-cyan',
    'bg-steam-green',
    'bg-steam-amber',
    'bg-purple-400',
    'bg-steam-red',
  ]

  return (
    <div className="space-y-4">
      <h3 className="text-steam-text text-sm font-semibold flex items-center gap-2">
        <Gamepad2 size={14} className="text-steam-cyan" />
        Your Gaming Profile
      </h3>

      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">

        {/* ── Top 3 juegos ─────────────────────────────────────────────────── */}
        <div className="glass rounded-xl p-4 space-y-3 sm:col-span-1">
          <div className="flex items-center gap-2 mb-1">
            <Trophy size={13} className="text-steam-amber" />
            <p className="text-steam-subtle text-xs font-mono uppercase tracking-wider">Most Played</p>
          </div>
          {insights.top3.length === 0 ? (
            <p className="text-steam-subtle text-xs">No playtime data yet</p>
          ) : (
            insights.top3.map((g, i) => (
              <div key={g.appid} className="flex items-center gap-3 group">
                {/* Rank */}
                <span className={`text-xs font-mono font-bold w-4 flex-shrink-0 ${
                  i === 0 ? 'text-steam-amber' : i === 1 ? 'text-steam-subtle' : 'text-steam-subtle/60'
                }`}>
                  {i === 0 ? '🥇' : i === 1 ? '🥈' : '🥉'}
                </span>

                {/* Thumbnail */}
                <div className="w-12 h-7 rounded bg-steam-muted overflow-hidden flex-shrink-0">
                  {steamImageUrl(g.appid) ? (
                    <img src={steamImageUrl(g.appid)!} alt={g.game_title}
                      className="w-full h-full object-cover" />
                  ) : (
                    <div className="w-full h-full bg-steam-muted" />
                  )}
                </div>

                {/* Info */}
                <div className="flex-1 min-w-0">
                  {g.game_id ? (
                    <Link href={`/game/${g.game_id}`}
                      className="text-steam-text text-xs font-semibold truncate block group-hover:text-steam-cyan transition-colors">
                      {g.game_title}
                    </Link>
                  ) : (
                    <p className="text-steam-text text-xs font-semibold truncate">{g.game_title}</p>
                  )}
                  <p className="text-steam-subtle text-xs font-mono">
                    {Math.round(g.playtime_mins / 60)}h played
                  </p>
                </div>
              </div>
            ))
          )}
        </div>

        {/* ── Géneros favoritos ─────────────────────────────────────────────── */}
        <div className="glass rounded-xl p-4 space-y-3 sm:col-span-1">
          <div className="flex items-center gap-2 mb-1">
            <Gamepad2 size={13} className="text-steam-cyan" />
            <p className="text-steam-subtle text-xs font-mono uppercase tracking-wider">Favorite Genres</p>
          </div>
          {insights.topGenres.length === 0 ? (
            <p className="text-steam-subtle text-xs">No genre data yet</p>
          ) : (
            <div className="space-y-2.5">
              {insights.topGenres.map(({ genre, hours, pct }, i) => (
                <div key={genre} className="space-y-1">
                  <div className="flex items-center justify-between">
                    <span className="text-steam-text text-xs font-medium">{genre}</span>
                    <span className="text-steam-subtle text-xs font-mono">{hours}h · {pct}%</span>
                  </div>
                  <div className="h-1.5 bg-steam-muted rounded-full overflow-hidden">
                    <div
                      className={`h-full rounded-full transition-all duration-700 ${genreColors[i] || 'bg-steam-cyan'}`}
                      style={{ width: `${pct}%` }}
                    />
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* ── Precio ahorrado estimado ──────────────────────────────────────── */}
        <div className="glass rounded-xl p-4 space-y-3 sm:col-span-1">
          <div className="flex items-center gap-2 mb-1">
            <DollarSign size={13} className="text-steam-green" />
            <p className="text-steam-subtle text-xs font-mono uppercase tracking-wider">Savings Estimate</p>
          </div>

          <div className="text-center py-2">
            <p className="font-display font-bold text-2xl text-steam-green">
              {formatPrice(insights.savedEstimate)}
            </p>
            <p className="text-steam-subtle text-xs mt-1 leading-relaxed">
              Estimated saved vs. avg price across{' '}
              <span className="text-steam-text">{insights.gamesOnSale}</span> tracked games
            </p>
          </div>

          <div className="border-t border-steam-border pt-3 space-y-1.5">
            <div className="flex justify-between text-xs">
              <span className="text-steam-subtle font-mono">Total library</span>
              <span className="text-steam-text font-mono font-semibold">{games.length} games</span>
            </div>
            <div className="flex justify-between text-xs">
              <span className="text-steam-subtle font-mono">Total hours</span>
              <span className="text-steam-text font-mono font-semibold">{insights.totalHours}h</span>
            </div>
            <div className="flex justify-between text-xs">
              <span className="text-steam-subtle font-mono">Tracked in DB</span>
              <span className="text-steam-text font-mono font-semibold">
                {games.filter(g => g.game_id).length} games
              </span>
            </div>
          </div>

          <p className="text-steam-subtle/50 text-xs italic leading-relaxed">
            * Estimate based on historical price data. Actual savings may vary.
          </p>
        </div>

      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\SeasonalChart.tsx
LINEAS: 90
============================================================

'use client'

import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Cell, ResponsiveContainer } from 'recharts'
import type { SeasonalPattern } from '@/lib/types'
import { MONTH_NAMES } from '@/lib/utils'

interface Props {
  patterns: SeasonalPattern[]
}

const CustomTooltip = ({ active, payload }: any) => {
  if (!active || !payload?.length) return null
  const d = payload[0].payload
  return (
    <div className="glass rounded-xl px-4 py-3 text-sm">
      <p className="text-steam-text font-semibold">{MONTH_NAMES[d.month]}</p>
      <p className="text-steam-cyan font-mono">{d.avg_discount.toFixed(1)}% avg discount</p>
      <p className="text-steam-subtle text-xs">{d.sample_count} data points</p>
    </div>
  )
}

export default function SeasonalChart({ patterns }: Props) {
  if (!patterns.length) return null

  // Fill missing months with 0
  const full = Array.from({ length: 12 }, (_, i) => {
    const month = i + 1
    const found = patterns.find(p => p.month === month)
    return { month, avg_discount: found?.avg_discount ?? 0, sample_count: found?.sample_count ?? 0 }
  })

  const maxDiscount = Math.max(...full.map(d => d.avg_discount))

  return (
    <div className="glass rounded-2xl p-6 space-y-4">
      <div>
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest mb-1">Seasonal Patterns</p>
        <p className="text-steam-text text-sm">Average discount by month</p>
      </div>

      <ResponsiveContainer width="100%" height={160}>
        <BarChart data={full} margin={{ top: 5, right: 5, bottom: 5, left: 0 }}>
          <CartesianGrid strokeDasharray="3 3" stroke="#1f2d45" vertical={false} />
          <XAxis
            dataKey="month"
            tickFormatter={m => MONTH_NAMES[m]}
            tick={{ fill: '#5c7a9e', fontSize: 10, fontFamily: 'var(--font-mono)' }}
            tickLine={false}
            axisLine={{ stroke: '#1f2d45' }}
          />
          <YAxis
            tickFormatter={v => `${v}%`}
            tick={{ fill: '#5c7a9e', fontSize: 10, fontFamily: 'var(--font-mono)' }}
            tickLine={false}
            axisLine={false}
            width={35}
          />
          <Tooltip content={<CustomTooltip />} />
          <Bar dataKey="avg_discount" radius={[3, 3, 0, 0]}>
            {full.map(entry => {
              const intensity = maxDiscount > 0 ? entry.avg_discount / maxDiscount : 0
              const isHigh = entry.month === 11 || entry.month === 12 || entry.month === 6 || entry.month === 7
              return (
                <Cell
                  key={entry.month}
                  fill={isHigh
                    ? `rgba(0, 255, 135, ${0.3 + intensity * 0.6})`
                    : `rgba(0, 212, 255, ${0.2 + intensity * 0.5})`
                  }
                />
              )
            })}
          </Bar>
        </BarChart>
      </ResponsiveContainer>

      <div className="flex gap-4 text-xs text-steam-subtle font-mono">
        <span className="flex items-center gap-1.5">
          <span className="w-2 h-2 rounded-sm bg-steam-green/60 inline-block" />
          Peak sale months
        </span>
        <span className="flex items-center gap-1.5">
          <span className="w-2 h-2 rounded-sm bg-steam-cyan/40 inline-block" />
          Other months
        </span>
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\components\StoreDeals.tsx
LINEAS: 102
============================================================

'use client'

import { useState, useEffect } from 'react'
import { ExternalLink, ShoppingCart, Loader2, Store } from 'lucide-react'
import { getCurrentPrices } from '@/lib/api'
import { formatPrice } from '@/lib/utils'
import type { StoreDeal } from '@/lib/types'

interface Props { gameId: string }

const STORE_ICONS: Record<string, string> = {
  'Steam': '🎮', 'GOG': '🪐', 'Epic Games Store': '⚡', 'Humble Store': '🙏',
  'Fanatical': '🎯', 'GreenManGaming': '🟢', 'GamersGate': '🎲',
  'Gamesplanet': '🌍', 'WinGameStore': '🏆',
}

export default function StoreDeals({ gameId }: Props) {
  const [deals, setDeals] = useState<StoreDeal[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(false)

  useEffect(() => {
    getCurrentPrices(gameId)
      .then(data => setDeals(data.deals))
      .catch(() => setError(true))
      .finally(() => setLoading(false))
  }, [gameId])

  if (loading) return (
    <div className="glass rounded-2xl p-6 flex items-center gap-3 text-steam-subtle">
      <Loader2 size={16} className="animate-spin text-steam-cyan" />
      <span className="text-sm">Loading current prices...</span>
    </div>
  )

  if (error || !deals.length) return (
    <div className="glass rounded-2xl p-5 text-center text-steam-subtle text-sm">
      <Store size={20} className="mx-auto mb-2 opacity-40" />
      No current deals found across stores.
    </div>
  )

  const cheapest = deals[0]

  return (
    <div className="glass rounded-2xl overflow-hidden">
      <div className="px-5 py-4 border-b border-steam-border">
        <p className="text-steam-subtle text-xs font-mono uppercase tracking-widest mb-0.5">Buy Now</p>
        <div className="flex items-center justify-between">
          <p className="text-steam-text text-sm font-semibold">Best price: <span className="text-steam-green font-mono">{formatPrice(cheapest.price_usd)}</span></p>
          <span className="text-steam-subtle text-xs">{deals.length} stores</span>
        </div>
      </div>

      <div className="divide-y divide-steam-border/50">
        {deals.map((deal, i) => {
          const isBest = i === 0
          const icon = STORE_ICONS[deal.shop_name] || '🛒'
          return (
            <div
              key={i}
              className={`flex items-center gap-4 px-5 py-3 transition-colors ${
                isBest ? 'bg-steam-green/5' : 'hover:bg-steam-muted/50'
              }`}
            >
              <span className="text-lg w-6 text-center flex-shrink-0">{icon}</span>

              <div className="flex-1 min-w-0">
                <p className={`text-sm font-medium truncate ${isBest ? 'text-steam-green' : 'text-steam-text'}`}>
                  {deal.shop_name}
                  {isBest && <span className="ml-2 text-xs font-mono text-steam-green/70">BEST</span>}
                </p>
                {deal.cut_pct > 0 && (
                  <p className="text-steam-subtle text-xs font-mono">
                    Was {formatPrice(deal.regular_usd)} · <span className="text-steam-amber">−{deal.cut_pct}%</span>
                  </p>
                )}
              </div>

              <div className="text-right flex-shrink-0">
                <p className={`font-mono font-bold text-sm ${isBest ? 'text-steam-green' : 'text-steam-text'}`}>
                  {formatPrice(deal.price_usd)}
                </p>
              </div>

              {deal.url && (
                <a
                  href={deal.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="flex-shrink-0 p-1.5 rounded-lg text-steam-subtle hover:text-steam-cyan hover:bg-steam-cyan/10 transition-colors"
                >
                  <ExternalLink size={14} />
                </a>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}


============================================================
ARCHIVO: frontend\src\lib\api.ts
LINEAS: 104
============================================================

import type {
  Game, SearchResult, PriceHistoryResponse, GameStatsResponse,
  PredictionResponse, CurrentPricesResponse, TopDeal, BuySignal, OverviewStats
} from './types'

const BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'

async function apiFetch<T>(path: string, revalidate = 60, fallback?: T): Promise<T> {
  const res = await fetch(`${BASE}${path}`, { next: { revalidate } })
  if (!res.ok) {
    if (fallback !== undefined) return fallback
    const err = await res.json().catch(() => ({ detail: res.statusText }))
    throw new Error(err.detail || `HTTP ${res.status}`)
  }
  return res.json()
}

// Health
export const getHealth = () => apiFetch<{ status: string; db: string; model: string }>('/health')

// Stats
export const getOverviewStats = () => apiFetch<OverviewStats>('/stats/overview', 30)

// Games
export const searchGames = (q: string) =>
  apiFetch<SearchResult[]>(`/games/search?q=${encodeURIComponent(q)}`, 0)

export const listGames = async (limit = 50, offset = 0): Promise<Game[]> => {
  const data = await apiFetch<any>(`/games?limit=${limit}&offset=${offset}`, 30)
  return Array.isArray(data) ? data : (data?.games ?? data?.list ?? [])
}

export const getGameStats = (gameId: string) =>
  apiFetch<GameStatsResponse>(`/games/${gameId}`, 60)

export const getTopDeals = async (limit = 24): Promise<TopDeal[]> => {
  const data = await apiFetch<any>(`/games/top/deals?limit=${limit}`, 30)
  return Array.isArray(data) ? data : (data?.deals ?? data?.list ?? [])
}

export const getTopBuySignals = async (limit = 24): Promise<BuySignal[]> => {
  const data = await apiFetch<any>(`/games/top/buy?limit=${limit}`, 30)
  return Array.isArray(data) ? data : (data?.signals ?? data?.list ?? [])
}

export const getCurrentPrices = (gameId: string) =>
  apiFetch<CurrentPricesResponse>(`/games/${gameId}/current-prices`, 10)

// Prices
export const getPriceHistory = (gameId: string, since?: string) =>
  apiFetch<PriceHistoryResponse>(
    `/prices/${gameId}/history${since ? `?since=${since}` : ''}`, 60,
    { game_id: gameId, title: '', count: 0, history: [] } as PriceHistoryResponse
  )

// Predictions
export const getPrediction = (gameId: string, forceRefresh = false) =>
  apiFetch<PredictionResponse>(`/predict/${gameId}${forceRefresh ? '?force_refresh=true' : ''}`, 0)

// Sync
export const syncByGameId = async (gameId: string) => {
  const res = await fetch(`${BASE}/sync/id/${encodeURIComponent(gameId)}`, { method: 'POST' })
  if (!res.ok) throw new Error('Sync failed')
  return res.json()
}

export const syncByAppid = async (appid: number) => {
  const res = await fetch(`${BASE}/sync/game/${appid}`, { method: 'POST' })
  if (!res.ok) throw new Error('Sync failed')
  return res.json()
}

// ── User / Auth ───────────────────────────────────────────────────────────────

async function userFetch<T>(path: string, token: string): Promise<T> {
  const res = await fetch(`${BASE}${path}`, {
    headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' }
  })
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  return res.json()
}

export const getMe = (token: string) =>
  userFetch<{ steam_id: string; display_name: string; avatar_url: string }>('/auth/me', token)

export const getLibrary = (token: string, sync = false) =>
  userFetch<any>(`/me/library${sync ? '?sync=true' : ''}`, token)

export const getWishlist = (token: string, sync = false) =>
  userFetch<any>(`/me/wishlist${sync ? '?sync=true' : ''}`, token)

export const getRecommendations = (token: string, limit = 12) =>
  userFetch<any>(`/me/recommendations?limit=${limit}`, token)

export const syncLibrary = (token: string) =>
  fetch(`${BASE}/me/library/sync`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${token}` }
  }).then(r => r.json())

export const checkOwned = (token: string, appid: number) =>
  userFetch<{ owned: boolean }>(`/me/owned/${appid}`, token)

export const steamLoginUrl = `${BASE}/auth/steam`


============================================================
ARCHIVO: frontend\src\lib\auth.ts
LINEAS: 46
============================================================

// Client-side auth helpers
export interface SteamUser {
  steam_id: string
  display_name: string
  avatar_url: string
}

export function getToken(): string | null {
  if (typeof window === 'undefined') return null
  return localStorage.getItem('steamsense_token')
}

export function setToken(token: string) {
  localStorage.setItem('steamsense_token', token)
}

export function clearToken() {
  localStorage.removeItem('steamsense_token')
}

export function authHeaders(): Record<string, string> {
  const token = getToken()
  return token ? { Authorization: `Bearer ${token}` } : {}
}

// Decode JWT payload without verification (verification happens server-side)
export function decodeToken(token: string): SteamUser | null {
  try {
    const payload = token.split('.')[1]
    const pad = 4 - payload.length % 4
    const decoded = JSON.parse(atob(payload + '='.repeat(pad === 4 ? 0 : pad)))
    if (!decoded.sub || decoded.exp < Date.now() / 1000) return null
    return {
      steam_id:     decoded.sub,
      display_name: decoded.name,
      avatar_url:   decoded.avatar || '',
    }
  } catch {
    return null
  }
}

export function getUserFromStorage(): SteamUser | null {
  const token = getToken()
  return token ? decodeToken(token) : null
}


============================================================
ARCHIVO: frontend\src\lib\types.ts
LINEAS: 126
============================================================

export interface Game {
  id: string
  slug: string
  title: string
  appid?: number
  total_records?: number
  min_price?: number
  max_discount?: number
}

export interface SearchResult {
  id: string
  slug: string
  title: string
  type?: string
}

export interface PricePoint {
  timestamp: string
  price_usd: number
  regular_usd: number
  cut_pct: number
  shop_name: string
}

export interface PriceHistoryResponse {
  game_id: string
  title: string
  appid?: number
  count: number
  history: PricePoint[]
}

export interface PriceStats {
  total_records: number
  first_seen: string
  last_seen: string
  min_price: number
  max_price: number
  avg_price: number
  max_discount: number
  avg_discount_when_on_sale: number
  avg_cut_q4: number
  avg_cut_summer: number
  days_since_min_price: number
}

export interface SeasonalPattern {
  month: number
  avg_discount: number
  sample_count: number
}

export interface GameStatsResponse {
  game_id: string
  title: string
  appid?: number
  stats: PriceStats
  seasonal_patterns: SeasonalPattern[]
}

export interface Prediction {
  score: number
  signal: 'BUY' | 'WAIT'
  reason: string
  confidence: number
}

export interface PriceContext {
  current_price: number
  min_price_ever: number
  avg_price: number
  current_discount_pct: number
}

export interface PredictionResponse {
  game_id: string
  title: string
  appid?: number
  prediction: Prediction
  price_context: PriceContext
  from_cache: boolean
}

export interface StoreDeal {
  shop_id?: number
  shop_name: string
  price_usd: number
  regular_usd: number
  cut_pct: number
  url?: string
}

export interface CurrentPricesResponse {
  game_id: string
  deals: StoreDeal[]
}

export interface TopDeal {
  id: string
  title: string
  appid?: number
  current_price: number
  regular_price: number
  discount_pct: number
  last_seen: string
  min_price: number
}

export interface BuySignal {
  id: string
  title: string
  appid?: number
  score: number
  signal: string
  reason: string
  current_price: number
  discount_pct: number
}

export interface OverviewStats {
  total_games: number
  total_records: number
  buy_signals: number
  wait_signals: number
}


============================================================
ARCHIVO: frontend\src\lib\utils.ts
LINEAS: 62
============================================================

import { type ClassValue, clsx } from 'clsx'

export function cn(...inputs: ClassValue[]) {
  return clsx(inputs)
}

export function formatPrice(usd: number | null | undefined): string {
  if (usd === null || usd === undefined) return '—'
  if (usd === 0) return 'FREE'
  return new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD', minimumFractionDigits: 2,
  }).format(usd)
}

export function formatDate(iso: string | null | undefined): string {
  if (!iso) return '—'
  return new Date(iso).toLocaleDateString('en-US', {
    month: 'short', day: 'numeric', year: 'numeric',
  })
}

export function formatDateShort(iso: string | null | undefined): string {
  if (!iso) return '—'
  return new Date(iso).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
}

export function timeAgo(iso: string | null | undefined): string {
  if (!iso) return '—'
  const diff = Date.now() - new Date(iso).getTime()
  const days = Math.floor(diff / 86400000)
  if (days === 0) return 'today'
  if (days === 1) return 'yesterday'
  if (days < 30) return `${days}d ago`
  const months = Math.floor(days / 30)
  if (months < 12) return `${months}mo ago`
  return `${Math.floor(months / 12)}y ago`
}

export const MONTH_NAMES = [
  '', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
]

export function steamImageUrl(appid: number | undefined | null, type: 'header' | 'capsule' = 'header'): string | null {
  if (!appid) return null
  if (type === 'header') return `https://cdn.cloudflare.steamstatic.com/steam/apps/${appid}/header.jpg`
  return `https://cdn.cloudflare.steamstatic.com/steam/apps/${appid}/capsule_231x87.jpg`
}

export function discountColor(pct: number): string {
  if (pct >= 75) return 'text-steam-green'
  if (pct >= 50) return 'text-emerald-400'
  if (pct >= 25) return 'text-steam-amber'
  return 'text-steam-subtle'
}

export function discountBg(pct: number): string {
  if (pct >= 75) return 'bg-steam-green/10 border-steam-green/30 text-steam-green'
  if (pct >= 50) return 'bg-emerald-500/10 border-emerald-500/30 text-emerald-400'
  if (pct >= 25) return 'bg-steam-amber/10 border-steam-amber/30 text-steam-amber'
  return 'bg-steam-muted border-steam-border text-steam-subtle'
}
